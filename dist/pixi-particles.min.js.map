{"version":3,"sources":["../src/PropertyNode.ts","../src/ParticleUtils.ts","../src/PropertyList.ts","../src/Particle.ts","../src/PolygonalChain.ts","../src/Emitter.ts","../src/PathParticle.ts","../src/AnimatedParticle.ts","../src/src/index.ts"],"names":["PropertyNode","value","time","ease","this","ParticleUtils","hexToRGB","next","isStepped","generateEase","createList","data","Array","isArray","list","array","node","first","length","i","start","end","verbose","DEG_TO_RADS","Math","PI","rotatePoint","angle","p","s","sin","c","cos","xnew","x","y","ynew","combineRGBComponents","r","g","b","normalize","point","oneOverLen","scaleBy","sqrt","color","output","alpha","charAt","substr","indexOf","parseInt","a","segments","qty","oneOverQty","t","cp","e","getBlendMode","name","BLEND_MODES","NORMAL","toUpperCase","replace","createSteppedGradient","numSteps","currentNode","current","nextIndex","lerp","curVal","nextVal","PropertyList","isColor","interpolate","prototype","reset","intColorSimple","intValueSimple","intColorStepped","intValueStepped","intColorComplex","intValueComplex","Particle","_super","emitter","_this","call","anchor","velocity","Point","maxLife","age","extraData","alphaList","speedList","speedMultiplier","acceleration","maxSpeed","NaN","scaleList","scaleMultiplier","colorList","_doAlpha","_doScale","_doSpeed","_doAcceleration","_doColor","_doNormalMovement","_oneOverLife","prev","init","Particle_init","update","Particle_update","Sprite_destroy","destroy","Particle_destroy","applyArt","kill","tslib_1.__extends","rotation","noRotation","rotationSpeed","scale","tint","visible","art","texture","Texture","EMPTY","delta","speed","currentSpeed","position","atan2","recycle","parent","removeChild","parseArt","fromImage","baseTexture","window","console","warn","parseData","Sprite","PolygonalChain","countingLengths","totalLength","chain","prevPoint","j","second","push","p1","p2","l","_a","segLength","getRandomPoint","out","chosenSeg","rand","random","ticker","tickerN","shared","helperPoint","Emitter","particleParent","particleImages","config","_particleConstructor","startAlpha","startSpeed","minimumSpeedMultiplier","startScale","minimumScaleMultiplier","startColor","minLifetime","maxLifetime","minStartRotation","maxStartRotation","minRotationSpeed","maxRotationSpeed","particleBlendMode","customEase","_frequency","spawnChance","maxParticles","emitterLifetime","spawnPos","spawnType","_spawnFunc","spawnRect","spawnCircle","spawnPolygonalChain","particlesPerWave","particleSpacing","angleStart","ownerPos","_prevEmitterPos","_prevPosIsValid","_posChanged","_parent","addAtBack","particleCount","_emit","_spawnTimer","_emitterLife","_activeParticlesFirst","_activeParticlesLast","_poolFirst","_origConfig","_origArt","_autoUpdate","_destroyWhenComplete","_completeCallback","rotate","updateSpawnPos","updateOwnerPos","Object","defineProperty","cleanup","particle","slice","partClass","startRotation","min","max","lifetime","blendMode","_spawnRect","Rectangle","w","h","_spawnCircle","Circle","_spawnRing","minRadius","minR","_spawnBurst","_spawnPoint","_spawnPolygonalChain","spawnPolygon","frequency","pos","clone","emit","undefined","autoUpdate","newRot","diff","resetPositionTracking","remove","add","playOnceAndDestroy","callback","playOnce","settings","TARGET_FPMS","prevX","prevY","curX","curY","emitPosX","emitPosY","len","particleConstructor","floor","children","shift","pop","index","splice","unshift","addChildAt","addChild","width","height","radius","MATH_FUNCS","WHITELISTER","RegExp","concat","join","PathParticle","path","initialRotation","initialPosition","movement","pathString","matches","match","Function","parsePath","error","AnimatedParticle","textures","duration","framerate","elapsed","loop","frame","tex","outTextures","outArr","dupe","count","ParticleRenderer","particles","ParticleContainer"],"mappings":"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","file":"dist/pixi-particles.min.js.map","sourcesContent":["import ParticleUtils, {EaseSegment, SimpleEase} from \"./ParticleUtils\";\n\nexport interface ValueStep {\n\tvalue:number|string;\n\ttime:number;\n}\n\nexport interface ValueList {\n\tlist: ValueStep[],\n\tisStepped?: boolean;\n\tease?: SimpleEase|EaseSegment[];\n}\n/**\n * A single node in a PropertyList.\n * @memberof PIXI.particles\n * @class PropertyNode\n * @constructor\n * @param {number|string} value The value for this node\n * @param {number} time The time for this node, between 0-1\n * @param {Function|Array} [ease] Custom ease for this list. Only relevant for the first node.\n */\nexport default class PropertyNode<V>\n{\n\t/**\n\t * Value for the node.\n\t * @property {number|Object} value\n\t */\n\tpublic value: V;\n\t/**\n\t * Time value for the node. Between 0-1.\n\t * @property {number} value\n\t */\n\tpublic time: number;\n\t/**\n\t * The next node in line.\n\t * @property {PIXI.particles.PropertyNode} next\n\t */\n\tpublic next: PropertyNode<V>;\n\t/**\n\t * If this is the first node in the list, controls if the entire list is stepped or not.\n\t * @property {boolean} isStepped\n\t */\n\tpublic isStepped: boolean;\n\tpublic ease: SimpleEase;\n\t\n\tconstructor(value: V|string, time:number, ease?: SimpleEase|EaseSegment[])\n\t{\n\t\tthis.value = typeof value == \"string\" ? ParticleUtils.hexToRGB(value) as any : value;\n\t\tthis.time = time;\n\t\tthis.next = null;\n\t\tthis.isStepped = false;\n\t\tif (ease)\n\t\t{\n\t\t\tthis.ease = typeof ease == \"function\" ? ease : ParticleUtils.generateEase(ease);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.ease = null;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a list of property values from a data object {list, isStepped} with a list of objects in\n\t * the form {value, time}. Alternatively, the data object can be in the deprecated form of\n\t * {start, end}.\n\t * @method PIXI.particles.PropertyNode.createListFromArray\n\t * @static\n\t * @param  {Object} data The data for the list.\n\t * @param  {Array} data.list The array of value and time objects.\n\t * @param  {boolean} [data.isStepped] If the list is stepped rather than interpolated.\n\t * @param  {Function|Array} [data.ease] Custom ease for this list.\n\t * @return {PIXI.particles.PropertyNode} The first node in the list\n\t */\n\tpublic static createList(data: ValueList):PropertyNode<any>\n\t{\n\t\tif (Array.isArray(data.list))\n\t\t{\n\t\t\tlet array = data.list;\n\t\t\tlet node, first;\n\t\t\tfirst = node = new PropertyNode(array[0].value, array[0].time, data.ease);\n\t\t\t//only set up subsequent nodes if there are a bunch or the 2nd one is different from the first\n\t\t\tif (array.length > 2 || (array.length === 2 && array[1].value !== array[0].value))\n\t\t\t{\n\t\t\t\tfor (let i = 1; i < array.length; ++i)\n\t\t\t\t{\n\t\t\t\t\tnode.next = new PropertyNode(array[i].value, array[i].time);\n\t\t\t\t\tnode = node.next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfirst.isStepped = !!data.isStepped;\n\t\t\treturn first;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Handle deprecated version here\n\t\t\tlet start = new PropertyNode((data as any).start, 0);\n\t\t\t//only set up a next value if it is different from the starting value\n\t\t\tif ((data as any).end !== (data as any).start)\n\t\t\t\tstart.next = new PropertyNode((data as any).end, 1);\n\t\t\treturn start;\n\t\t}\n\t}\n}","import {BLEND_MODES, Point} from 'pixi.js';\nimport PropertyNode, {ValueStep} from './PropertyNode';\n\nexport interface Color {\n\tr: number,\n\tg: number,\n\tb: number,\n\ta?: number\n}\n\nexport interface EaseSegment {\n\tcp:number;\n\ts:number;\n\te:number;\n}\n\nexport type SimpleEase = (time:number) => number;\n\n/**\n * Contains helper functions for particles and emitters to use.\n * @memberof PIXI.particles\n * @class ParticleUtils\n * @static\n */\nconst ParticleUtils = {\n\t/**\n\t * If errors and warnings should be logged within the library.\n\t * @name PIXI.particles.ParticleUtils.verbose\n\t * @default false\n\t * @static\n\t */\n\tverbose: false,\n\n\tDEG_TO_RADS: Math.PI / 180,\n\n\t/**\n\t * Rotates a point by a given angle.\n\t * @method PIXI.particles.ParticleUtils.rotatePoint\n\t * @param {Number} angle The angle to rotate by in degrees\n\t * @param {PIXI.Point} p The point to rotate around 0,0.\n\t * @static\n\t */\n\trotatePoint(angle:number, p:Point): void\n\t{\n\t\tif (!angle) return;\n\t\tangle *= ParticleUtils.DEG_TO_RADS;\n\t\tconst s = Math.sin(angle);\n\t\tconst c = Math.cos(angle);\n\t\tconst xnew = p.x * c - p.y * s;\n\t\tconst ynew = p.x * s + p.y * c;\n\t\tp.x = xnew;\n\t\tp.y = ynew;\n\t},\n\n\t/**\n\t * Combines separate color components (0-255) into a single uint color.\n\t * @method PIXI.particles.ParticleUtils.combineRGBComponents\n\t * @param {uint} r The red value of the color\n\t * @param {uint} g The green value of the color\n\t * @param {uint} b The blue value of the color\n\t * @return {uint} The color in the form of 0xRRGGBB\n\t * @static\n\t */\n\tcombineRGBComponents(r:number, g:number, b:number/*, a*/): number\n\t{\n\t\treturn /*a << 24 |*/ r << 16 | g << 8 | b;\n\t},\n\n\t/**\n\t * Reduces the point to a length of 1.\n\t * @method PIXI.particles.ParticleUtils.normalize\n\t * @static\n\t * @param {PIXI.Point} point The point to normalize\n\t */\n\tnormalize(point:Point): void\n\t{\n\t\tlet oneOverLen = 1 / ParticleUtils.length(point);\n\t\tpoint.x *= oneOverLen;\n\t\tpoint.y *= oneOverLen;\n\t},\n\n\t/**\n\t * Multiplies the x and y values of this point by a value.\n\t * @method PIXI.particles.ParticleUtils.scaleBy\n\t * @static\n\t * @param {PIXI.Point} point The point to scaleBy\n\t * @param {number} value The value to scale by.\n\t */\n\tscaleBy(point:Point, value:number): void\n\t{\n\t\tpoint.x *= value;\n\t\tpoint.y *= value;\n\t},\n\n\t/**\n\t * Returns the length (or magnitude) of this point.\n\t * @method PIXI.particles.ParticleUtils.length\n\t * @static\n\t * @param {PIXI.Point} point The point to measure length\n\t * @return The length of this point.\n\t */\n\tlength(point:Point): number\n\t{\n\t\treturn Math.sqrt(point.x * point.x + point.y * point.y);\n\t},\n\n\t/**\n\t * Converts a hex string from \"#AARRGGBB\", \"#RRGGBB\", \"0xAARRGGBB\", \"0xRRGGBB\",\n\t * \"AARRGGBB\", or \"RRGGBB\" to an object of ints of 0-255, as\n\t * {r, g, b, (a)}.\n\t * @method PIXI.particles.ParticleUtils.hexToRGB\n\t * @param {string} color The input color string.\n\t * @param {Object} [output] An object to put the output in. If omitted, a new object is created.\n\t * @return The object with r, g, and b properties, possibly with an a property.\n\t * @static\n\t */\n\thexToRGB(color:string, output?:Color): Color\n\t{\n\t\tif (!output)\n\t\t\toutput = {} as Color;\n\t\tif (color.charAt(0) == \"#\")\n\t\t\tcolor = color.substr(1);\n\t\telse if (color.indexOf(\"0x\") === 0)\n\t\t\tcolor = color.substr(2);\n\t\tlet alpha;\n\t\tif (color.length == 8)\n\t\t{\n\t\t\talpha = color.substr(0, 2);\n\t\t\tcolor = color.substr(2);\n\t\t}\n\t\toutput.r = parseInt(color.substr(0, 2), 16);//Red\n\t\toutput.g = parseInt(color.substr(2, 2), 16);//Green\n\t\toutput.b = parseInt(color.substr(4, 2), 16);//Blue\n\t\tif (alpha)\n\t\t\toutput.a = parseInt(alpha, 16);\n\t\treturn output;\n\t},\n\n\t/**\n\t * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated\n\t * by the related tool at http://www.greensock.com/customease/.\n\t * @method PIXI.particles.ParticleUtils.generateEase\n\t * @param {Array} segments An array of segments, as created by\n\t * http://www.greensock.com/customease/.\n\t * @return {Function} A function that calculates the percentage of change at\n\t *                    a given point in time (0-1 inclusive).\n\t * @static\n\t */\n\tgenerateEase(segments:EaseSegment[]): SimpleEase\n\t{\n\t\tconst qty = segments.length;\n\t\tconst oneOverQty = 1 / qty;\n\t\t/*\n\t\t * Calculates the percentage of change at a given point in time (0-1 inclusive).\n\t\t * @param {Number} time The time of the ease, 0-1 inclusive.\n\t\t * @return {Number} The percentage of the change, 0-1 inclusive (unless your\n\t\t *                  ease goes outside those bounds).\n\t\t */\n\t\treturn function(time:number)\n\t\t{\n\t\t\tlet t: number, s: EaseSegment;\n\t\t\tlet i = (qty * time) | 0;//do a quick floor operation\n\t\t\tt = (time - (i * oneOverQty)) * qty;\n\t\t\ts = segments[i] || segments[qty - 1];\n\t\t\treturn (s.s + t * (2 * (1 - t) * (s.cp - s.s) + t * (s.e - s.s)));\n\t\t};\n\t},\n\n\t/**\n\t * Gets a blend mode, ensuring that it is valid.\n\t * @method PIXI.particles.ParticleUtils.getBlendMode\n\t * @param {string} name The name of the blend mode to get.\n\t * @return {int} The blend mode as specified in the PIXI.BLEND_MODES enumeration.\n\t * @static\n\t */\n\tgetBlendMode(name:string): number\n\t{\n\t\tif (!name) return BLEND_MODES.NORMAL;\n\t\tname = name.toUpperCase();\n\t\twhile (name.indexOf(\" \") >= 0)\n\t\t\tname = name.replace(\" \", \"_\");\n\t\treturn (BLEND_MODES as any)[name] || BLEND_MODES.NORMAL;\n\t},\n\n\t/**\n\t * Converts a list of {value, time} objects starting at time 0 and ending at time 1 into an evenly\n\t * spaced stepped list of PropertyNodes for color values. This is primarily to handle conversion of\n\t * linear gradients to fewer colors, allowing for some optimization for Canvas2d fallbacks.\n\t * @method PIXI.particles.ParticleUtils.createSteppedGradient\n\t * @param {Array} list The list of data to convert.\n\t * @param {number} [numSteps=10] The number of steps to use.\n\t * @return {PIXI.particles.PropertyNode} The blend mode as specified in the PIXI.blendModes enumeration.\n\t * @static\n\t */\n\tcreateSteppedGradient(list:ValueStep[], numSteps:number = 10) {\n\t\tif (typeof numSteps !== 'number' || numSteps <= 0)\n\t\t\tnumSteps = 10;\n\t\tlet first = new PropertyNode<Color>(list[0].value as string, list[0].time);\n\t\tfirst.isStepped = true;\n\t\tlet currentNode = first;\n\t\tlet current = list[0];\n\t\tlet nextIndex = 1;\n\t\tlet next = list[nextIndex];\n\t\tfor (let i = 1; i < numSteps; ++i)\n\t\t{\n\t\t\tlet lerp = i / numSteps;\n\t\t\t//ensure we are on the right segment, if multiple\n\t\t\twhile (lerp > next.time)\n\t\t\t{\n\t\t\t\tcurrent = next;\n\t\t\t\tnext = list[++nextIndex];\n\t\t\t}\n\t\t\t//convert the lerp value to the segment range\n\t\t\tlerp = (lerp - current.time) / (next.time - current.time);\n\t\t\tlet curVal = ParticleUtils.hexToRGB(current.value as string);\n\t\t\tlet nextVal = ParticleUtils.hexToRGB(next.value as string);\n\t\t\tlet output:Color = {} as Color;\n\t\t\toutput.r = (nextVal.r - curVal.r) * lerp + curVal.r;\n\t\t\toutput.g = (nextVal.g - curVal.g) * lerp + curVal.g;\n\t\t\toutput.b = (nextVal.b - curVal.b) * lerp + curVal.b;\n\t\t\tcurrentNode.next = new PropertyNode(output, i / numSteps);\n\t\t\tcurrentNode = currentNode.next;\n\t\t}\n\t\t//we don't need to have a PropertyNode for time of 1, because in a stepped version at that point\n\t\t//the particle has died of old age\n\t\treturn first;\n\t}\n};\n\nexport default ParticleUtils;","import ParticleUtils, {SimpleEase, Color} from \"./ParticleUtils\";\nimport PropertyNode from \"./PropertyNode\";\n\n/**\n * Singly linked list container for keeping track of interpolated properties for particles.\n * Each Particle will have one of these for each interpolated property.\n * @memberof PIXI.particles\n * @class PropertyList\n * @constructor\n * @param {boolean} isColor If this list handles color values\n */\nexport default class PropertyList<V>\n{\n\t/**\n\t * The current property node in the linked list.\n\t * @property {PIXI.particles.PropertyNode} current\n\t */\n\tpublic current: PropertyNode<V>;\n\t/**\n\t * The next property node in the linked list. Stored separately for slightly less variable\n\t * access.\n\t * @property {PIXI.particles.PropertyNode} next\n\t */\n\tpublic next: PropertyNode<V>;\n\t/**\n\t * Calculates the correct value for the current interpolation value. This method is set in\n\t * the reset() method.\n\t * @method interpolate\n\t * @param {number} lerp The interpolation value from 0-1.\n\t * @return {number} Either the interpolated value. Colors are converted to the hex value.\n\t */\n\tpublic interpolate: SimpleEase;\n\t/**\n\t * A custom easing method for this list.\n\t * @method ease\n\t * @param {number} lerp The interpolation value from 0-1.\n\t * @return {number} The eased value, also from 0-1.\n\t */\n\tpublic ease: SimpleEase;\n\t/**\n\t * If this list manages colors, which requires a different method for interpolation.\n\t * @property {boolean} isColor\n\t * @private\n\t */\n\tprivate isColor: boolean;\n\t\n\tconstructor(isColor: boolean = false)\n\t{\n\t\tthis.current = null;\n\t\tthis.next = null;\n\t\tthis.isColor = !!isColor;\n\t\tthis.interpolate = null;\n\t\tthis.ease = null;\n\t}\n\n\t/**\n\t * Resets the list for use.\n\t * @method interpolate\n\t * @param {PIXI.particles.PropertyNode} first The first node in the list.\n\t * @param {boolean} [isStepped=false] If the values should be stepped instead of interpolated linearly.\n\t */\n\tpublic reset(first: PropertyNode<V>)\n\t{\n\t\tthis.current = first;\n\t\tthis.next = first.next;\n\t\tconst isSimple = this.next && this.next.time >= 1;\n\t\tif (isSimple)\n\t\t{\n\t\t\tthis.interpolate = this.isColor ? intColorSimple : intValueSimple;\n\t\t}\n\t\telse if (first.isStepped)\n\t\t{\n\t\t\tthis.interpolate = this.isColor ? intColorStepped : intValueStepped;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.interpolate = this.isColor ? intColorComplex : intValueComplex;\n\t\t}\n\t\tthis.ease = this.current.ease;\n\t}\n}\n\nfunction intValueSimple(this: PropertyList<number>, lerp: number)\n{\n\tif (this.ease)\n\t\tlerp = this.ease(lerp);\n\treturn (this.next.value - this.current.value) * lerp + this.current.value;\n}\n\nfunction intColorSimple(this: PropertyList<Color>, lerp: number)\n{\n\tif (this.ease)\n\t\tlerp = this.ease(lerp);\n\tlet curVal = this.current.value, nextVal = this.next.value;\n\tlet r = (nextVal.r - curVal.r) * lerp + curVal.r;\n\tlet g = (nextVal.g - curVal.g) * lerp + curVal.g;\n\tlet b = (nextVal.b - curVal.b) * lerp + curVal.b;\n\treturn ParticleUtils.combineRGBComponents(r, g, b);\n}\n\nfunction intValueComplex(this: PropertyList<number>, lerp: number)\n{\n\tif (this.ease)\n\t\tlerp = this.ease(lerp);\n\t//make sure we are on the right segment\n\twhile (lerp > this.next.time)\n\t{\n\t\tthis.current = this.next;\n\t\tthis.next = this.next.next;\n\t}\n\t//convert the lerp value to the segment range\n\tlerp = (lerp - this.current.time) / (this.next.time - this.current.time);\n\treturn (this.next.value - this.current.value) * lerp + this.current.value;\n}\n\nfunction intColorComplex(this: PropertyList<Color>, lerp: number)\n{\n\tif (this.ease)\n\t\tlerp = this.ease(lerp);\n\t//make sure we are on the right segment\n\twhile (lerp > this.next.time)\n\t{\n\t\tthis.current = this.next;\n\t\tthis.next = this.next.next;\n\t}\n\t//convert the lerp value to the segment range\n\tlerp = (lerp - this.current.time) / (this.next.time - this.current.time);\n\tlet curVal = this.current.value, nextVal = this.next.value;\n\tlet r = (nextVal.r - curVal.r) * lerp + curVal.r;\n\tlet g = (nextVal.g - curVal.g) * lerp + curVal.g;\n\tlet b = (nextVal.b - curVal.b) * lerp + curVal.b;\n\treturn ParticleUtils.combineRGBComponents(r, g, b);\n}\n\nfunction intValueStepped(this: PropertyList<number>, lerp: number)\n{\n\tif (this.ease)\n\t\tlerp = this.ease(lerp);\n\t//make sure we are on the right segment\n\twhile (this.next && lerp > this.next.time)\n\t{\n\t\tthis.current = this.next;\n\t\tthis.next = this.next.next;\n\t}\n\treturn this.current.value;\n}\n\nfunction intColorStepped(this: PropertyList<Color>, lerp: number)\n{\n\tif (this.ease)\n\t\tlerp = this.ease(lerp);\n\t//make sure we are on the right segment\n\twhile (this.next && lerp > this.next.time)\n\t{\n\t\tthis.current = this.next;\n\t\tthis.next = this.next.next;\n\t}\n\tlet curVal = this.current.value;\n\treturn ParticleUtils.combineRGBComponents(curVal.r, curVal.g, curVal.b);\n}","import Emitter from \"./Emitter\";\nimport ParticleUtils, {SimpleEase, Color} from \"./ParticleUtils\";\nimport PropertyList from \"./PropertyList\";\nimport {Sprite, Point, Texture} from 'pixi.js';\n\n/**\n * An individual particle image. You shouldn't have to deal with these.\n * @memberof PIXI.particles\n * @class Particle\n * @extends PIXI.Sprite\n * @constructor\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this particle.\n */\nexport default class Particle extends Sprite\n{\n\t/**\n\t * The emitter that controls this particle.\n\t * @property {Emitter} emitter\n\t */\n\tpublic emitter: Emitter;\n\t/**\n\t * The velocity of the particle. Speed may change, but the angle also\n\t * contained in velocity is constant.\n\t * @property {PIXI.Point} velocity\n\t */\n\tpublic velocity: Point;\n\t/**\n\t * The maximum lifetime of this particle, in seconds.\n\t * @property {Number} maxLife\n\t */\n\tpublic maxLife: number;\n\t/**\n\t * The current age of the particle, in seconds.\n\t * @property {Number} age\n\t */\n\tpublic age: number;\n\t/**\n\t * A simple easing function to be applied to all properties that\n\t * are being interpolated.\n\t * @property {Function} ease\n\t */\n\tpublic ease: SimpleEase;\n\t/**\n\t * Extra data that the emitter passes along for custom particles.\n\t * @property {Object} extraData\n\t */\n\tpublic extraData: any;\n\t/**\n\t * The alpha of the particle throughout its life.\n\t * @property {PIXI.particles.PropertyList} alphaList\n\t */\n\tpublic alphaList: PropertyList<number>;\n\t/**\n\t * The speed of the particle throughout its life.\n\t * @property {PIXI.particles.PropertyList} speedList\n\t */\n\tpublic speedList: PropertyList<number>;\n\t/**\n\t * A multiplier from 0-1 applied to the speed of the particle at all times.\n\t * @property {number} speedMultiplier\n\t */\n\tpublic speedMultiplier: number;\n\t/**\n\t * Acceleration to apply to the particle.\n\t * @property {PIXI.Point} accleration\n\t */\n\tpublic acceleration: Point;\n\t/**\n\t * The maximum speed allowed for accelerating particles. Negative values, values of 0 or NaN\n\t * will disable the maximum speed.\n\t * @property {Number} maxSpeed\n\t * @default NaN\n\t */\n\tpublic maxSpeed: number;\n\t/**\n\t * Speed at which the particle rotates, in radians per second.\n\t * @property {Number} rotationSpeed\n\t */\n\tpublic rotationSpeed: number;\n\t/**\n\t * If particle rotation is locked, preventing rotation from occurring due\n\t * to directional changes.\n\t * @property {Number} noRotation\n\t */\n\tpublic noRotation: boolean;\n\t/**\n\t * The scale of the particle throughout its life.\n\t * @property {PIXI.particles.PropertyList} scaleList\n\t */\n\tpublic scaleList: PropertyList<number>;\n\t/**\n\t * A multiplier from 0-1 applied to the scale of the particle at all times.\n\t * @property {number} scaleMultiplier\n\t */\n\tpublic scaleMultiplier: number;\n\t/**\n\t * The tint of the particle throughout its life.\n\t * @property {PIXI.particles.PropertyList} colorList\n\t */\n\tpublic colorList: PropertyList<Color>;\n\t/**\n\t * A reference to init, so that subclasses can access it without the penalty of Function.call()\n\t * @method PIXI.particles.Particle#Particle_init\n\t * @protected\n\t */\n\tprotected Particle_init: () => void;\n\t/**\n\t * A reference to update so that subclasses can access the original without the overhead\n\t * of Function.call().\n\t * @method PIXI.particles.Particle#Particle_update\n\t * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n\t * @return {Number} The standard interpolation multiplier (0-1) used for all relevant particle\n\t *                   properties. A value of -1 means the particle died of old age instead.\n\t * @protected\n\t */\n\tprotected Particle_update: (delta: number) => number;\n\tprotected Particle_destroy: () => void;\n\tprotected Sprite_destroy: () => void;\n\t/**\n\t * If alpha should be interpolated at all.\n\t * @property {Boolean} _doAlpha\n\t * @private\n\t */\n\tprotected _doAlpha: boolean;\n\t/**\n\t * If scale should be interpolated at all.\n\t * @property {Boolean} _doScale\n\t * @private\n\t */\n\tprotected _doScale: boolean;\n\t/**\n\t * If speed should be interpolated at all.\n\t * @property {Boolean} _doSpeed\n\t * @private\n\t */\n\tprotected _doSpeed: boolean;\n\t/**\n\t * If acceleration should be handled at all. _doSpeed is mutually exclusive with this,\n\t * and _doSpeed gets priority.\n\t * @property {Boolean} _doAcceleration\n\t * @private\n\t */\n\tprotected _doAcceleration: boolean;\n\t/**\n\t * If color should be interpolated at all.\n\t * @property {Boolean} _doColor\n\t * @private\n\t */\n\tprotected _doColor: boolean;\n\t/**\n\t * If normal movement should be handled. Subclasses wishing to override movement\n\t * can set this to false in init().\n\t * @property {Boolean} _doNormalMovement\n\t * @private\n\t */\n\tprotected _doNormalMovement: boolean;\n\t/**\n\t * One divided by the max life of the particle, saved for slightly faster math.\n\t * @property {Number} _oneOverLife\n\t * @private\n\t */\n\tprivate _oneOverLife: number;\n\t/**\n\t * Reference to the next particle in the list.\n\t * @property {Particle} next\n\t * @private\n\t */\n\tpublic next: Particle;\n\n\t/**\n\t * Reference to the previous particle in the list.\n\t * @property {Particle} prev\n\t * @private\n\t */\n\tpublic prev: Particle;\n\t\n\tconstructor(emitter: Emitter)\n\t{\n\t\t//start off the sprite with a blank texture, since we are going to replace it\n\t\t//later when the particle is initialized.\n\t\tsuper();\n\t\tthis.emitter = emitter;\n\t\t//particles should be centered\n\t\tthis.anchor.x = this.anchor.y = 0.5;\n\t\tthis.velocity = new Point();\n\t\tthis.maxLife = 0;\n\t\tthis.age = 0;\n\t\tthis.ease = null;\n\t\tthis.extraData = null;\n\t\tthis.alphaList = new PropertyList();\n\t\tthis.speedList = new PropertyList();\n\t\tthis.speedMultiplier = 1;\n\t\t/**\n\t\t * Acceleration to apply to the particle.\n\t\t * @property {PIXI.Point} accleration\n\t\t */\n\t\tthis.acceleration = new Point();\n\t\t/**\n\t\t * The maximum speed allowed for accelerating particles. Negative values, values of 0 or NaN\n\t\t * will disable the maximum speed.\n\t\t * @property {Number} maxSpeed\n\t\t * @default NaN\n\t\t */\n\t\tthis.maxSpeed = NaN;\n\t\t/**\n\t\t * The scale of the particle throughout its life.\n\t\t * @property {PIXI.particles.PropertyList} scaleList\n\t\t */\n\t\tthis.scaleList = new PropertyList();\n\t\t/**\n\t\t * A multiplier from 0-1 applied to the scale of the particle at all times.\n\t\t * @property {number} scaleMultiplier\n\t\t */\n\t\tthis.scaleMultiplier = 1;\n\t\t/**\n\t\t * The tint of the particle throughout its life.\n\t\t * @property {PIXI.particles.PropertyList} colorList\n\t\t */\n\t\tthis.colorList = new PropertyList(true);\n\t\t/**\n\t\t * If alpha should be interpolated at all.\n\t\t * @property {Boolean} _doAlpha\n\t\t * @private\n\t\t */\n\t\tthis._doAlpha = false;\n\t\t/**\n\t\t * If scale should be interpolated at all.\n\t\t * @property {Boolean} _doScale\n\t\t * @private\n\t\t */\n\t\tthis._doScale = false;\n\t\t/**\n\t\t * If speed should be interpolated at all.\n\t\t * @property {Boolean} _doSpeed\n\t\t * @private\n\t\t */\n\t\tthis._doSpeed = false;\n\t\t/**\n\t\t * If acceleration should be handled at all. _doSpeed is mutually exclusive with this,\n\t\t * and _doSpeed gets priority.\n\t\t * @property {Boolean} _doAcceleration\n\t\t * @private\n\t\t */\n\t\tthis._doAcceleration = false;\n\t\t/**\n\t\t * If color should be interpolated at all.\n\t\t * @property {Boolean} _doColor\n\t\t * @private\n\t\t */\n\t\tthis._doColor = false;\n\t\t/**\n\t\t * If normal movement should be handled. Subclasses wishing to override movement\n\t\t * can set this to false in init().\n\t\t * @property {Boolean} _doNormalMovement\n\t\t * @private\n\t\t */\n\t\tthis._doNormalMovement = false;\n\t\t/**\n\t\t * One divided by the max life of the particle, saved for slightly faster math.\n\t\t * @property {Number} _oneOverLife\n\t\t * @private\n\t\t */\n\t\tthis._oneOverLife = 0;\n\n\t\t/**\n\t\t * Reference to the next particle in the list.\n\t\t * @property {Particle} next\n\t\t * @private\n\t\t */\n\t\tthis.next = null;\n\n\t\t/**\n\t\t * Reference to the previous particle in the list.\n\t\t * @property {Particle} prev\n\t\t * @private\n\t\t */\n\t\tthis.prev = null;\n\n\t\t//save often used functions on the instance instead of the prototype for better speed\n\t\tthis.init = this.init;\n\t\tthis.Particle_init = Particle.prototype.init;\n\t\tthis.update = this.update;\n\t\tthis.Particle_update = Particle.prototype.update;\n\t\tthis.Sprite_destroy = super.destroy;\n\t\tthis.Particle_destroy = Particle.prototype.destroy;\n\t\tthis.applyArt = this.applyArt;\n\t\tthis.kill = this.kill;\n\t}\n\n\t/**\n\t * Initializes the particle for use, based on the properties that have to\n\t * have been set already on the particle.\n\t * @method PIXI.particles.Particle#init\n\t */\n\tpublic init()\n\t{\n\t\t//reset the age\n\t\tthis.age = 0;\n\t\t//set up the velocity based on the start speed and rotation\n\t\tthis.velocity.x = this.speedList.current.value * this.speedMultiplier;\n\t\tthis.velocity.y = 0;\n\t\tParticleUtils.rotatePoint(this.rotation, this.velocity);\n\t\tif (this.noRotation)\n\t\t{\n\t\t\tthis.rotation = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//convert rotation to Radians from Degrees\n\t\t\tthis.rotation *= ParticleUtils.DEG_TO_RADS;\n\t\t}\n\t\t//convert rotation speed to Radians from Degrees\n\t\tthis.rotationSpeed *= ParticleUtils.DEG_TO_RADS;\n\t\t//set alpha to inital alpha\n\t\tthis.alpha = this.alphaList.current.value;\n\t\t//set scale to initial scale\n\t\tthis.scale.x = this.scale.y = this.scaleList.current.value;\n\t\t//figure out what we need to interpolate\n\t\tthis._doAlpha = !!this.alphaList.current.next;\n\t\tthis._doSpeed = !!this.speedList.current.next;\n\t\tthis._doScale = !!this.scaleList.current.next;\n\t\tthis._doColor = !!this.colorList.current.next;\n\t\tthis._doAcceleration = this.acceleration.x !== 0 || this.acceleration.y !== 0;\n\t\t//_doNormalMovement can be cancelled by subclasses\n\t\tthis._doNormalMovement = this._doSpeed || this.speedList.current.value !== 0 || this._doAcceleration;\n\t\t//save our lerp helper\n\t\tthis._oneOverLife = 1 / this.maxLife;\n\t\t//set the inital color\n\t\tlet color = this.colorList.current.value;\n\t\tthis.tint = ParticleUtils.combineRGBComponents(color.r, color.g, color.b);\n\t\t//ensure visibility\n\t\tthis.visible = true;\n\t}\n\n\t/**\n\t * Sets the texture for the particle. This can be overridden to allow\n\t * for an animated particle.\n\t * @method PIXI.particles.Particle#applyArt\n\t * @param {PIXI.Texture} art The texture to set.\n\t */\n\tpublic applyArt(art: any)\n\t{\n\t\tthis.texture = art || Texture.EMPTY;\n\t}\n\n\t/**\n\t * Updates the particle.\n\t * @method PIXI.particles.Particle#update\n\t * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n\t * @return {Number} The standard interpolation multiplier (0-1) used for all relevant particle\n\t *                   properties. A value of -1 means the particle died of old age instead.\n\t */\n\tpublic update(delta: number): number\n\t{\n\t\t//increase age\n\t\tthis.age += delta;\n\t\t//recycle particle if it is too old\n\t\tif(this.age >= this.maxLife || this.age < 0)\n\t\t{\n\t\t\tthis.kill();\n\t\t\treturn -1;\n\t\t}\n\n\t\t//determine our interpolation value\n\t\tlet lerp = this.age * this._oneOverLife;//lifetime / maxLife;\n\t\tif (this.ease)\n\t\t{\n\t\t\tif(this.ease.length == 4)\n\t\t\t{\n\t\t\t\t//the t, b, c, d parameters that some tween libraries use\n\t\t\t\t//(time, initial value, end value, duration)\n\t\t\t\tlerp = (this.ease as any)(lerp, 0, 1, 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//the simplified version that we like that takes\n\t\t\t\t//one parameter, time from 0-1. TweenJS eases provide this usage.\n\t\t\t\tlerp = this.ease(lerp);\n\t\t\t}\n\t\t}\n\n\t\t//interpolate alpha\n\t\tif (this._doAlpha)\n\t\t\tthis.alpha = this.alphaList.interpolate(lerp);\n\t\t//interpolate scale\n\t\tif (this._doScale)\n\t\t{\n\t\t\tlet scale = this.scaleList.interpolate(lerp) * this.scaleMultiplier;\n\t\t\tthis.scale.x = this.scale.y = scale;\n\t\t}\n\t\t//handle movement\n\t\tif(this._doNormalMovement)\n\t\t{\n\t\t\t//interpolate speed\n\t\t\tif (this._doSpeed)\n\t\t\t{\n\t\t\t\tlet speed = this.speedList.interpolate(lerp) * this.speedMultiplier;\n\t\t\t\tParticleUtils.normalize(this.velocity);\n\t\t\t\tParticleUtils.scaleBy(this.velocity, speed);\n\t\t\t}\n\t\t\telse if(this._doAcceleration)\n\t\t\t{\n\t\t\t\tthis.velocity.x += this.acceleration.x * delta;\n\t\t\t\tthis.velocity.y += this.acceleration.y * delta;\n\t\t\t\tif (this.maxSpeed)\n\t\t\t\t{\n\t\t\t\t\tlet currentSpeed = ParticleUtils.length(this.velocity);\n\t\t\t\t\t//if we are going faster than we should, clamp at the max speed\n\t\t\t\t\t//DO NOT recalculate vector length\n\t\t\t\t\tif (currentSpeed > this.maxSpeed)\n\t\t\t\t\t{\n\t\t\t\t\t\tParticleUtils.scaleBy(this.velocity, this.maxSpeed / currentSpeed);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//adjust position based on velocity\n\t\t\tthis.position.x += this.velocity.x * delta;\n\t\t\tthis.position.y += this.velocity.y * delta;\n\t\t}\n\t\t//interpolate color\n\t\tif (this._doColor)\n\t\t{\n\t\t\tthis.tint = this.colorList.interpolate(lerp);\n\t\t}\n\t\t//update rotation\n\t\tif(this.rotationSpeed !== 0)\n\t\t{\n\t\t\tthis.rotation += this.rotationSpeed * delta;\n\t\t}\n\t\telse if(this.acceleration && !this.noRotation)\n\t\t{\n\t\t\tthis.rotation = Math.atan2(this.velocity.y, this.velocity.x);// + Math.PI / 2;\n\t\t}\n\t\treturn lerp;\n\t}\n\n\t/**\n\t * Kills the particle, removing it from the display list\n\t * and telling the emitter to recycle it.\n\t * @method PIXI.particles.Particle#kill\n\t */\n\tpublic kill()\n\t{\n\t\tthis.emitter.recycle(this);\n\t}\n\n\t/**\n\t * Destroys the particle, removing references and preventing future use.\n\t * @method PIXI.particles.Particle#destroy\n\t */\n\tpublic destroy()\n\t{\n\t\tif (this.parent)\n\t\t\tthis.parent.removeChild(this);\n\t\tthis.Sprite_destroy();\n\t\tthis.emitter = this.velocity = this.colorList = this.scaleList = this.alphaList =\n\t\t\tthis.speedList = this.ease = this.next = this.prev = null;\n\t}\n\n\t/**\n\t * Checks over the art that was passed to the Emitter's init() function, to do any special\n\t * modifications to prepare it ahead of time.\n\t * @method PIXI.particles.Particle.parseArt\n\t * @static\n\t * @param  {Array} art The array of art data. For Particle, it should be an array of Textures.\n\t *                     Any strings in the array will be converted to Textures via\n\t *                     Texture.fromImage().\n\t * @return {Array} The art, after any needed modifications.\n\t */\n\tpublic static parseArt(art:any[]): any[]\n\t{\n\t\t//convert any strings to Textures.\n\t\tlet i;\n\t\tfor(i = art.length; i >= 0; --i)\n\t\t{\n\t\t\tif(typeof art[i] == \"string\")\n\t\t\t\tart[i] = Texture.fromImage(art[i]);\n\t\t}\n\t\t//particles from different base textures will be slower in WebGL than if they\n\t\t//were from one spritesheet\n\t\tif(ParticleUtils.verbose)\n\t\t{\n\t\t\tfor(i = art.length - 1; i > 0; --i)\n\t\t\t{\n\t\t\t\tif(art[i].baseTexture != art[i - 1].baseTexture)\n\t\t\t\t{\n\t\t\t\t\tif (window.console)\n\t\t\t\t\t\tconsole.warn(\"PixiParticles: using particle textures from different images may hinder performance in WebGL\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn art;\n\t}\n\n\t/**\n\t * Parses extra emitter data to ensure it is set up for this particle class.\n\t * Particle does nothing to the extra data.\n\t * @method PIXI.particles.Particle.parseData\n\t * @static\n\t * @param  {Object} extraData The extra data from the particle config.\n\t * @return {Object} The parsed extra data.\n\t */\n\tpublic static parseData(extraData: any): any\n\t{\n\t\treturn extraData;\n\t}\n}","import {Point} from 'pixi.js';\n\ninterface BasicPoint\n{\n\tx: number;\n\ty: number;\n}\n\ninterface Segment\n{\n\tp1: BasicPoint;\n\tp2: BasicPoint;\n\tl: number;\n}\n\n/**\n * Chain of line segments for generating spawn positions.\n * @memberof PIXI.particles\n * @class PolygonalChain\n * @constructor\n * @param {PIXI.PointLike[]|PIXI.PointLike[][]} data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\n */\nexport default class PolygonalChain\n{\n\t/**\n\t * List of segment objects in the chain.\n\t * @property {object[]} segments\n\t * @private\n\t */\n\tprivate segments:Segment[];\n\t/**\n\t * Total length of all segments of the chain.\n\t * @property {number} totalLength\n\t * @private\n\t */\n\tprivate totalLength:number;\n\t/**\n\t * Total length of segments up to and including the segment of the same index.\n\t * Used for weighted random selection of segment.\n\t * @property {number[]} countingLengths\n\t * @private\n\t */\n\tprivate countingLengths:number[];\n\tconstructor(data:BasicPoint[]|BasicPoint[][])\n\t{\n\t\tthis.segments = [];\n\t\tthis.countingLengths = [];\n\t\tthis.totalLength = 0;\n\t\tthis.init(data);\n\t}\n\t\n\tprivate init(data:BasicPoint[]|BasicPoint[][])\n\t{\n\t\t// if data is not present, set up a segment of length 0\n\t\tif (!data || !data.length)\n\t\t{\n\t\t\tthis.segments.push({p1:{x:0, y:0}, p2:{x:0, y:0}, l:0});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Array.isArray(data[0]))\n\t\t\t{\n\t\t\t\t// list of segment chains, each defined as a list of points\n\t\t\t\tfor (let i = 0; i < data.length; ++i)\n\t\t\t\t{\n\t\t\t\t\t// loop through the chain, connecting points\n\t\t\t\t\tconst chain = data[i] as BasicPoint[];\n\t\t\t\t\tlet prevPoint = chain[0] as BasicPoint;\n\t\t\t\t\tfor (let j = 1; j < chain.length; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst second = chain[j] as BasicPoint;\n\t\t\t\t\t\tthis.segments.push({p1: prevPoint, p2: second, l:0});\n\t\t\t\t\t\tprevPoint = second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlet prevPoint = data[0] as BasicPoint;\n\t\t\t\t// list of points\n\t\t\t\tfor (let i = 1; i < data.length; ++i)\n\t\t\t\t{\n\t\t\t\t\tconst second = data[i] as BasicPoint;\n\t\t\t\t\tthis.segments.push({p1: prevPoint, p2: second, l:0});\n\t\t\t\t\tprevPoint = second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// now go through our segments to calculate the lengths so that we\n\t\t// can set up a nice weighted random distribution\n\t\tfor (let i = 0; i < this.segments.length; ++i) {\n\t\t\tconst {p1, p2} = this.segments[i];\n\t\t\tconst segLength = Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\n\t\t\t// save length so we can turn a random number into a 0-1 interpolation value later\n\t\t\tthis.segments[i].l = segLength;\n\t\t\tthis.totalLength += segLength;\n\t\t\t// keep track of the length so far, counting up\n\t\t\tthis.countingLengths.push(this.totalLength);\n\t\t}\n\t}\n\t\n\t/**\n\t * Gets a random point in the chain.\n\t * @method getRandomPoint\n\t * @param {PIXI.Point} out The point to store the selected position in.\n\t */\n\tpublic getRandomPoint(out:Point)\n\t{\n\t\t// select a random spot in the length of the chain\n\t\tconst rand = Math.random() * this.totalLength;\n\t\tlet chosenSeg:Segment;\n\t\tlet lerp:number;\n\t\t// if only one segment, it wins\n\t\tif (this.segments.length === 1)\n\t\t{\n\t\t\tchosenSeg = this.segments[0];\n\t\t\tlerp = rand;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// otherwise, go through countingLengths until we have determined\n\t\t\t// which segment we chose\n\t\t\tfor (let i = 0; i < this.countingLengths.length; ++i) {\n\t\t\t\tif (rand < this.countingLengths[i])\n\t\t\t\t{\n\t\t\t\t\tchosenSeg = this.segments[i];\n\t\t\t\t\t// set lerp equal to the length into that segment (i.e. the remainder after subtracting all the segments before it)\n\t\t\t\t\tlerp = i === 0 ? rand : rand - this.countingLengths[i - 1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// divide lerp by the segment length, to result in a 0-1 number.\n\t\tlerp /= chosenSeg.l || 1;\n\t\tconst {p1, p2} = chosenSeg;\n\t\t// now calculate the position in the segment that the lerp value represents\n\t\tout.x = p1.x + lerp * (p2.x - p1.x);\n\t\tout.y = p1.y + lerp * (p2.y - p1.y);\n\t}\n}","import ParticleUtils, {Color, SimpleEase} from \"./ParticleUtils\";\nimport Particle from \"./Particle\";\nimport PropertyNode from \"./PropertyNode\";\nimport PolygonalChain from \"./PolygonalChain\";\nimport {ticker as tickerN, Point, Circle, Rectangle, Container, settings} from 'pixi.js';\nimport ticker = tickerN.shared;\n\nexport interface ParticleConstructor {\n\tnew (emitter:Emitter):Particle;\n}\n\nconst helperPoint = new Point();\n\n/**\n * A particle emitter.\n * @memberof PIXI.particles\n * @class Emitter\n * @constructor\n * @param {PIXI.Container} particleParent The container to add the\n *                                                     particles to.\n * @param {Array|PIXI.Texture|String} [particleImages] A texture or array of textures to use\n *                                                     for the particles. Strings will be turned\n *                                                     into textures via Texture.fromImage().\n * @param {Object} [config] A configuration object containing settings for the emitter.\n * @param {Boolean} [config.emit=true] If config.emit is explicitly passed as false, the Emitter\n *                                     will start disabled.\n * @param {Boolean} [config.autoUpdate=false] If config.emit is explicitly passed as true, the Emitter\n *                                     will automatically call update via the PIXI shared ticker.\n */\nexport default class Emitter\n{\n\t/**\n\t * The constructor used to create new particles. The default is\n\t * the built in particle class.\n\t * @property {Function} _particleConstructor\n\t * @private\n\t */\n\tprotected _particleConstructor: typeof Particle;\n\t//properties for individual particles\n\t/**\n\t * An array of PIXI Texture objects.\n\t * @property {Array} particleImages\n\t */\n\tpublic particleImages: any[];\n\t/**\n\t * The first node in the list of alpha values for all particles.\n\t * @property {PIXI.particles.PropertyNode} startAlpha\n\t */\n\tpublic startAlpha: PropertyNode<number>;\n\t/**\n\t * The first node in the list of speed values of all particles.\n\t * @property {Number} startSpeed\n\t */\n\tpublic startSpeed: PropertyNode<number>;\n\t/**\n\t * A minimum multiplier for the speed of a particle at all stages of its life. A value between\n\t * minimumSpeedMultiplier and 1 is randomly generated for each particle.\n\t * @property {Number} minimumSpeedMultiplier\n\t * @default 1\n\t */\n\tpublic minimumSpeedMultiplier: number;\n\t/**\n\t * Acceleration to apply to particles. Using this disables\n\t * any interpolation of particle speed. If the particles do\n\t * not have a rotation speed, then they will be rotated to\n\t * match the direction of travel.\n\t * @property {PIXI.Point} acceleration\n\t * @default null\n\t */\n\tpublic acceleration: Point;\n\t/**\n\t * The maximum speed allowed for accelerating particles. Negative values, values of 0 or NaN\n\t * will disable the maximum speed.\n\t * @property {Number} maxSpeed\n\t * @default NaN\n\t */\n\tpublic maxSpeed: number;\n\t/**\n\t * The first node in the list of scale values of all particles.\n\t * @property {PIXI.particles.PropertyNode} startScale\n\t */\n\tpublic startScale: PropertyNode<number>;\n\t/**\n\t * A minimum multiplier for the scale of a particle at all stages of its life. A value between\n\t * minimumScaleMultiplier and 1 is randomly generated for each particle.\n\t * @property {Number} minimumScaleMultiplier\n\t * @default 1\n\t */\n\tpublic minimumScaleMultiplier: number;\n\t/**\n\t * The first node in the list of  color values of all particles, as red, green, and blue\n\t * uints from 0-255.\n\t * @property {PIXI.particles.PropertyNode} startColor\n\t */\n\tpublic startColor: PropertyNode<Color>;\n\t/**\n\t * The minimum lifetime for a particle, in seconds.\n\t * @property {Number} minLifetime\n\t */\n\tpublic minLifetime: number;\n\t/**\n\t * The maximum lifetime for a particle, in seconds.\n\t * @property {Number} maxLifetime\n\t */\n\tpublic maxLifetime: number;\n\t/**\n\t * The minimum start rotation for a particle, in degrees. This value\n\t * is ignored if the spawn type is \"burst\" or \"arc\".\n\t * @property {Number} minStartRotation\n\t */\n\tpublic minStartRotation: number;\n\t/**\n\t * The maximum start rotation for a particle, in degrees. This value\n\t * is ignored if the spawn type is \"burst\" or \"arc\".\n\t * @property {Number} maxStartRotation\n\t */\n\tpublic maxStartRotation: number;\n\t/**\n\t * If no particle rotation should occur. Starting rotation will still\n\t * affect the direction in which particles move. If the rotation speed\n\t * is set, then this will be ignored.\n\t * @property {Boolean} maxStartRotation\n\t */\n\tpublic noRotation: boolean;\n\t/**\n\t * The minimum rotation speed for a particle, in degrees per second.\n\t * This only visually spins the particle, it does not change direction\n\t * of movement.\n\t * @property {Number} minRotationSpeed\n\t */\n\tpublic minRotationSpeed: number;\n\t/**\n\t * The maximum rotation speed for a particle, in degrees per second.\n\t * This only visually spins the particle, it does not change direction\n\t * of movement.\n\t * @property {Number} maxRotationSpeed\n\t */\n\tpublic maxRotationSpeed: number;\n\t/**\n\t * The blend mode for all particles, as named by PIXI.blendModes.\n\t * @property {int} particleBlendMode\n\t */\n\tpublic particleBlendMode: number;\n\t/**\n\t * An easing function for nonlinear interpolation of values. Accepts a single\n\t * parameter of time as a value from 0-1, inclusive. Expected outputs are values\n\t * from 0-1, inclusive.\n\t * @property {Function} customEase\n\t */\n\tpublic customEase: SimpleEase;\n\t/**\n\t *\tExtra data for use in custom particles. The emitter doesn't look inside, but\n\t *\tpasses it on to the particle to use in init().\n\t *\t@property {Object} extraData\n\t */\n\tpublic extraData: any;\n\t//properties for spawning particles\n\t/**\n\t * Time between particle spawns in seconds.\n\t * @property {Number} _frequency\n\t * @private\n\t */\n\tprotected _frequency: number;\n\t/**\n\t * Chance that a particle will be spawned on each opportunity to spawn one.\n\t * 0 is 0%, 1 is 100%.\n\t * @property {Number} spawnChance\n\t */\n\tpublic spawnChance: number;\n\t/**\n\t * Maximum number of particles to keep alive at a time. If this limit\n\t * is reached, no more particles will spawn until some have died.\n\t * @property {int} maxParticles\n\t * @default 1000\n\t */\n\tpublic maxParticles: number;\n\t/**\n\t * The amount of time in seconds to emit for before setting emit to false.\n\t * A value of -1 is an unlimited amount of time.\n\t * @property {Number} emitterLifetime\n\t * @default -1\n\t */\n\tpublic emitterLifetime: number;\n\t/**\n\t * Position at which to spawn particles, relative to the emitter's owner's origin.\n\t * For example, the flames of a rocket travelling right might have a spawnPos\n\t * of {x:-50, y:0}.\n\t * to spawn at the rear of the rocket.\n\t * To change this, use updateSpawnPos().\n\t * @property {PIXI.Point} spawnPos\n\t * @readOnly\n\t */\n\tpublic spawnPos: Point;\n\t/**\n\t * How the particles will be spawned. Valid types are \"point\", \"rectangle\",\n\t * \"circle\", \"burst\", \"ring\".\n\t * @property {String} spawnType\n\t * @readOnly\n\t */\n\tpublic spawnType: string;\n\t/**\n\t * A reference to the emitter function specific to the spawn type.\n\t * @property {Function} _spawnFunc\n\t * @private\n\t */\n\tprivate _spawnFunc: (p: Particle, emitPosX: number, emitPosY: number, i?: number) => void;\n\t/**\n\t * A rectangle relative to spawnPos to spawn particles inside if the spawn type is \"rect\".\n\t * @property {PIXI.Rectangle} spawnRect\n\t */\n\tpublic spawnRect: Rectangle;\n\t/**\n\t * A polygon relative to spawnPos to spawn particles on the chain if the spawn type is \"polygonalChain\".\n\t * @property {PIXI.particles.PolygonalChain} spawnPolygonalChain\n\t */\n\tpublic spawnPolygonalChain: PolygonalChain;\n\t/**\n\t * A circle relative to spawnPos to spawn particles inside if the spawn type is \"circle\".\n\t * @property {PIXI.Circle} spawnCircle\n\t */\n\tpublic spawnCircle: Circle & {minRadius: number};\n\t/**\n\t * Number of particles to spawn time that the frequency allows for particles to spawn.\n\t * @property {int} particlesPerWave\n\t * @default 1\n\t */\n\tpublic particlesPerWave: number;\n\t/**\n\t * Spacing between particles in a burst. 0 gives a random angle for each particle.\n\t * @property {Number} particleSpacing\n\t * @default 0\n\t */\n\tpublic particleSpacing: number;\n\t/**\n\t * Angle at which to start spawning particles in a burst.\n\t * @property {Number} angleStart\n\t * @default 0\n\t */\n\tpublic angleStart: number;\n\t/**\n\t * Rotation of the emitter or emitter's owner in degrees. This is added to\n\t * the calculated spawn angle.\n\t * To change this, use rotate().\n\t * @property {Number} rotation\n\t * @default 0\n\t * @readOnly\n\t */\n\tpublic rotation: number;\n\t/**\n\t * The world position of the emitter's owner, to add spawnPos to when\n\t * spawning particles. To change this, use updateOwnerPos().\n\t * @property {PIXI.Point} ownerPos\n\t * @default {x:0, y:0}\n\t * @readOnly\n\t */\n\tpublic ownerPos: Point;\n\t/**\n\t * The origin + spawnPos in the previous update, so that the spawn position\n\t * can be interpolated to space out particles better.\n\t * @property {PIXI.Point} _prevEmitterPos\n\t * @private\n\t */\n\tprotected _prevEmitterPos: Point;\n\t/**\n\t * If _prevEmitterPos is valid, to prevent interpolation on the first update\n\t * @property {Boolean} _prevPosIsValid\n\t * @private\n\t * @default false\n\t */\n\tprotected _prevPosIsValid: boolean;\n\t/**\n\t * If either ownerPos or spawnPos has changed since the previous update.\n\t * @property {Boolean} _posChanged\n\t * @private\n\t */\n\tprotected _posChanged: boolean;\n\t/**\n\t * The container to add particles to.\n\t * @property {PIXI.Container} _parent\n\t * @private\n\t */\n\tprotected _parent: Container;\n\t/**\n\t * If particles should be added at the back of the display list instead of the front.\n\t * @property {Boolean} addAtBack\n\t */\n\tpublic addAtBack: boolean;\n\t/**\n\t * The current number of active particles.\n\t * @property {Number} particleCount\n\t * @readOnly\n\t */\n\tpublic particleCount: number;\n\t/**\n\t * If particles should be emitted during update() calls. Setting this to false\n\t * stops new particles from being created, but allows existing ones to die out.\n\t * @property {Boolean} _emit\n\t * @private\n\t */\n\tprotected _emit: boolean;\n\t/**\n\t * The timer for when to spawn particles in seconds, where numbers less\n\t * than 0 mean that particles should be spawned.\n\t * @property {Number} _spawnTimer\n\t * @private\n\t */\n\tprotected _spawnTimer: number;\n\t/**\n\t * The life of the emitter in seconds.\n\t * @property {Number} _emitterLife\n\t * @private\n\t */\n\tprotected _emitterLife: number;\n\t/**\n\t * The particles that are active and on the display list. This is the first particle in a\n\t * linked list.\n\t * @property {Particle} _activeParticlesFirst\n\t * @private\n\t */\n\tprotected _activeParticlesFirst: Particle;\n\t/**\n\t * The particles that are active and on the display list. This is the last particle in a\n\t * linked list.\n\t * @property {Particle} _activeParticlesLast\n\t * @private\n\t */\n\tprotected _activeParticlesLast: Particle;\n\t/**\n\t * The particles that are not currently being used. This is the first particle in a\n\t * linked list.\n\t * @property {Particle} _poolFirst\n\t * @private\n\t */\n\tprotected _poolFirst: Particle;\n\t/**\n\t * The original config object that this emitter was initialized with.\n\t * @property {Object} _origConfig\n\t * @private\n\t */\n\tprotected _origConfig: any;\n\t/**\n\t * The original particle image data that this emitter was initialized with.\n\t * @property {PIXI.Texture|Array|String} _origArt\n\t * @private\n\t */\n\tprotected _origArt: any;\n\t/**\n\t * If the update function is called automatically from the shared ticker.\n\t * Setting this to false requires calling the update function manually.\n\t * @property {Boolean} _autoUpdate\n\t * @private\n\t */\n\tprotected _autoUpdate: boolean;\n\t/**\n\t * If the emitter should destroy itself when all particles have died out. This is set by\n\t * playOnceAndDestroy();\n\t * @property {Boolean} _destroyWhenComplete\n\t * @private\n\t */\n\tprotected _destroyWhenComplete: boolean;\n\t/**\n\t * A callback for when all particles have died out. This is set by\n\t * playOnceAndDestroy() or playOnce();\n\t * @property {Function} _completeCallback\n\t * @private\n\t */\n\tprotected _completeCallback: () => void;\n\t\n\tconstructor(particleParent: Container, particleImages: any, config: any)\n\t{\n\t\tthis._particleConstructor = Particle;\n\t\t//properties for individual particles\n\t\tthis.particleImages = null;\n\t\tthis.startAlpha = null;\n\t\tthis.startSpeed = null;\n\t\tthis.minimumSpeedMultiplier = 1;\n\t\tthis.acceleration = null;\n\t\tthis.maxSpeed = NaN;\n\t\tthis.startScale = null;\n\t\tthis.minimumScaleMultiplier = 1;\n\t\tthis.startColor = null;\n\t\tthis.minLifetime = 0;\n\t\tthis.maxLifetime = 0;\n\t\tthis.minStartRotation = 0;\n\t\tthis.maxStartRotation = 0;\n\t\tthis.noRotation = false;\n\t\tthis.minRotationSpeed = 0;\n\t\tthis.maxRotationSpeed = 0;\n\t\tthis.particleBlendMode = 0;\n\t\tthis.customEase = null;\n\t\tthis.extraData = null;\n\t\t//properties for spawning particles\n\t\tthis._frequency = 1;\n\t\tthis.spawnChance = 1;\n\t\tthis.maxParticles = 1000;\n\t\tthis.emitterLifetime = -1;\n\t\tthis.spawnPos = null;\n\t\tthis.spawnType = null;\n\t\tthis._spawnFunc = null;\n\t\tthis.spawnRect = null;\n\t\tthis.spawnCircle = null;\n\t\tthis.spawnPolygonalChain = null;\n\t\tthis.particlesPerWave = 1;\n\t\tthis.particleSpacing = 0;\n\t\tthis.angleStart = 0;\n\t\t//emitter properties\n\t\tthis.rotation = 0;\n\t\tthis.ownerPos = null;\n\t\tthis._prevEmitterPos = null;\n\t\tthis._prevPosIsValid = false;\n\t\tthis._posChanged = false;\n\t\tthis._parent = null;\n\t\tthis.addAtBack = false;\n\t\tthis.particleCount = 0;\n\t\tthis._emit = false;\n\t\tthis._spawnTimer = 0;\n\t\tthis._emitterLife = -1;\n\t\tthis._activeParticlesFirst = null;\n\t\tthis._activeParticlesLast = null;\n\t\tthis._poolFirst = null;\n\t\tthis._origConfig = null;\n\t\tthis._origArt = null;\n\t\tthis._autoUpdate = false;\n\t\tthis._destroyWhenComplete = false;\n\t\tthis._completeCallback = null;\n\n\t\t//set the initial parent\n\t\tthis.parent = particleParent;\n\n\t\tif(particleImages && config)\n\t\t\tthis.init(particleImages, config);\n\n\t\t//save often used functions on the instance instead of the prototype for better speed\n\t\tthis.recycle = this.recycle;\n\t\tthis.update = this.update;\n\t\tthis.rotate = this.rotate;\n\t\tthis.updateSpawnPos = this.updateSpawnPos;\n\t\tthis.updateOwnerPos = this.updateOwnerPos;\n\t}\n\n\t/**\n\t * Time between particle spawns in seconds. If this value is not a number greater than 0,\n\t * it will be set to 1 (particle per second) to prevent infinite loops.\n\t * @member {Number} PIXI.particles.Emitter#frequency\n\t */\n\tpublic get frequency() { return this._frequency; }\n\tpublic set frequency(value)\n\t{\n\t\t//do some error checking to prevent infinite loops\n\t\tif(typeof value == \"number\" && value > 0)\n\t\t\tthis._frequency = value;\n\t\telse\n\t\t\tthis._frequency = 1;\n\t}\n\t/**\n\t * The constructor used to create new particles. The default is\n\t * the built in Particle class. Setting this will dump any active or\n\t * pooled particles, if the emitter has already been used.\n\t * @member {Function} PIXI.particles.Emitter#particleConstructor\n\t */\n\tpublic get particleConstructor() { return this._particleConstructor; }\n\tpublic set particleConstructor(value)\n\t{\n\t\tif(value != this._particleConstructor)\n\t\t{\n\t\t\tthis._particleConstructor = value;\n\t\t\t//clean up existing particles\n\t\t\tthis.cleanup();\n\t\t\t//scrap all the particles\n\t\t\tfor (let particle = this._poolFirst; particle; particle = particle.next)\n\t\t\t{\n\t\t\t\tparticle.destroy();\n\t\t\t}\n\t\t\tthis._poolFirst = null;\n\t\t\t//re-initialize the emitter so that the new constructor can do anything it needs to\n\t\t\tif(this._origConfig && this._origArt)\n\t\t\t\tthis.init(this._origArt, this._origConfig);\n\t\t}\n\t}\n\n\t/**\n\t* The container to add particles to. Settings this will dump any active particles.\n\t* @member {PIXI.Container} PIXI.particles.Emitter#parent\n\t*/\n\tpublic get parent() { return this._parent; }\n\tpublic set parent(value)\n\t{\n\t\tthis.cleanup();\n\t\tthis._parent = value;\n\t}\n\n\t/**\n\t * Sets up the emitter based on the config settings.\n\t * @method PIXI.particles.Emitter#init\n\t * @param {Array|PIXI.Texture} art A texture or array of textures to use for the particles.\n\t * @param {Object} config A configuration object containing settings for the emitter.\n\t */\n\tpublic init(art: any, config: any)\n\t{\n\t\tif(!art || !config)\n\t\t\treturn;\n\t\t//clean up any existing particles\n\t\tthis.cleanup();\n\n\t\t//store the original config and particle images, in case we need to re-initialize\n\t\t//when the particle constructor is changed\n\t\tthis._origConfig = config;\n\t\tthis._origArt = art;\n\n\t\t//set up the array of data, also ensuring that it is an array\n\t\tart = Array.isArray(art) ? art.slice() : [art];\n\t\t//run the art through the particle class's parsing function\n\t\tconst partClass = this._particleConstructor;\n\t\tthis.particleImages = partClass.parseArt ? partClass.parseArt(art) : art;\n\t\t///////////////////////////\n\t\t// Particle Properties   //\n\t\t///////////////////////////\n\t\t//set up the alpha\n\t\tif (config.alpha)\n\t\t{\n\t\t\tthis.startAlpha = PropertyNode.createList(config.alpha);\n\t\t}\n\t\telse\n\t\t\tthis.startAlpha = new PropertyNode(1, 0);\n\t\t//set up the speed\n\t\tif (config.speed)\n\t\t{\n\t\t\tthis.startSpeed = PropertyNode.createList(config.speed);\n\t\t\tthis.minimumSpeedMultiplier = config.speed.minimumSpeedMultiplier || 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.minimumSpeedMultiplier = 1;\n\t\t\tthis.startSpeed = new PropertyNode(0, 0);\n\t\t}\n\t\t//set up acceleration\n\t\tlet acceleration = config.acceleration;\n\t\tif(acceleration && (acceleration.x || acceleration.y))\n\t\t{\n\t\t\t//make sure we disable speed interpolation\n\t\t\tthis.startSpeed.next = null;\n\t\t\tthis.acceleration = new Point(acceleration.x, acceleration.y);\n\t\t\tthis.maxSpeed = config.maxSpeed || NaN;\n\t\t}\n\t\telse\n\t\t\tthis.acceleration = new Point();\n\t\t//set up the scale\n\t\tif (config.scale)\n\t\t{\n\t\t\tthis.startScale = PropertyNode.createList(config.scale);\n\t\t\tthis.minimumScaleMultiplier = config.scale.minimumScaleMultiplier || 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.startScale = new PropertyNode(1, 0);\n\t\t\tthis.minimumScaleMultiplier = 1;\n\t\t}\n\t\t//set up the color\n\t\tif (config.color)\n\t\t{\n\t\t\tthis.startColor = PropertyNode.createList(config.color);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.startColor = new PropertyNode({r:0xFF, g:0xFF, b:0xFF}, 0);\n\t\t}\n\t\t//set up the start rotation\n\t\tif (config.startRotation)\n\t\t{\n\t\t\tthis.minStartRotation = config.startRotation.min;\n\t\t\tthis.maxStartRotation = config.startRotation.max;\n\t\t}\n\t\telse\n\t\t\tthis.minStartRotation = this.maxStartRotation = 0;\n\t\tif (config.noRotation &&\n\t\t\t(this.minStartRotation || this.maxStartRotation))\n\t\t{\n\t\t\tthis.noRotation = !!config.noRotation;\n\t\t}\n\t\telse\n\t\t\tthis.noRotation = false;\n\t\t//set up the rotation speed\n\t\tif (config.rotationSpeed)\n\t\t{\n\t\t\tthis.minRotationSpeed = config.rotationSpeed.min;\n\t\t\tthis.maxRotationSpeed = config.rotationSpeed.max;\n\t\t}\n\t\telse\n\t\t\tthis.minRotationSpeed = this.maxRotationSpeed = 0;\n\t\t//set up the lifetime\n\t\tthis.minLifetime = config.lifetime.min;\n\t\tthis.maxLifetime = config.lifetime.max;\n\t\t//get the blend mode\n\t\tthis.particleBlendMode = ParticleUtils.getBlendMode(config.blendMode);\n\t\t//use the custom ease if provided\n\t\tif (config.ease)\n\t\t{\n\t\t\tthis.customEase = typeof config.ease == \"function\" ?\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconfig.ease :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tParticleUtils.generateEase(config.ease);\n\t\t}\n\t\telse\n\t\t\tthis.customEase = null;\n\t\t//set up the extra data, running it through the particle class's parseData function.\n\t\tif(partClass.parseData)\n\t\t\tthis.extraData = partClass.parseData(config.extraData);\n\t\telse\n\t\t\tthis.extraData = config.extraData || null;\n\t\t//////////////////////////\n\t\t// Emitter Properties   //\n\t\t//////////////////////////\n\t\t//reset spawn type specific settings\n\t\tthis.spawnRect = this.spawnCircle = null;\n\t\tthis.particlesPerWave = 1;\n\t\tif (config.particlesPerWave && config.particlesPerWave > 1)\n\t\t\tthis.particlesPerWave = config.particlesPerWave;\n\t\tthis.particleSpacing = 0;\n\t\tthis.angleStart = 0;\n\t\tlet spawnCircle;\n\t\t//determine the spawn function to use\n\t\tswitch(config.spawnType)\n\t\t{\n\t\t\tcase \"rect\":\n\t\t\t\tthis.spawnType = \"rect\";\n\t\t\t\tthis._spawnFunc = this._spawnRect;\n\t\t\t\tlet spawnRect = config.spawnRect;\n\t\t\t\tthis.spawnRect = new Rectangle(spawnRect.x, spawnRect.y, spawnRect.w, spawnRect.h);\n\t\t\t\tbreak;\n\t\t\tcase \"circle\":\n\t\t\t\tthis.spawnType = \"circle\";\n\t\t\t\tthis._spawnFunc = this._spawnCircle;\n\t\t\t\tspawnCircle = config.spawnCircle;\n\t\t\t\tthis.spawnCircle = new Circle(spawnCircle.x, spawnCircle.y, spawnCircle.r) as any;\n\t\t\t\tbreak;\n\t\t\tcase \"ring\":\n\t\t\t\tthis.spawnType = \"ring\";\n\t\t\t\tthis._spawnFunc = this._spawnRing;\n\t\t\t\tspawnCircle = config.spawnCircle;\n\t\t\t\tthis.spawnCircle = new Circle(spawnCircle.x, spawnCircle.y, spawnCircle.r) as any;\n\t\t\t\tthis.spawnCircle.minRadius = spawnCircle.minR;\n\t\t\t\tbreak;\n\t\t\tcase \"burst\":\n\t\t\t\tthis.spawnType = \"burst\";\n\t\t\t\tthis._spawnFunc = this._spawnBurst;\n\t\t\t\tthis.particleSpacing = config.particleSpacing;\n\t\t\t\tthis.angleStart = config.angleStart ? config.angleStart : 0;\n\t\t\t\tbreak;\n\t\t\tcase \"point\":\n\t\t\t\tthis.spawnType = \"point\";\n\t\t\t\tthis._spawnFunc = this._spawnPoint;\n\t\t\t\tbreak;\n\t\t\tcase \"polygonalChain\":\n\t\t\t\tthis.spawnType = \"polygonalChain\";\n\t\t\t\tthis._spawnFunc = this._spawnPolygonalChain;\n\t\t\t\tthis.spawnPolygonalChain = new PolygonalChain(config.spawnPolygon);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.spawnType = \"point\";\n\t\t\t\tthis._spawnFunc = this._spawnPoint;\n\t\t\t\tbreak;\n\t\t}\n\t\t//set the spawning frequency\n\t\tthis.frequency = config.frequency;\n\t\tthis.spawnChance = (typeof config.spawnChance === 'number' && config.spawnChance > 0) ? config.spawnChance : 1;\n\t\t//set the emitter lifetime\n\t\tthis.emitterLifetime = config.emitterLifetime || -1;\n\t\t//set the max particles\n\t\tthis.maxParticles = config.maxParticles > 0 ? config.maxParticles : 1000;\n\t\t//determine if we should add the particle at the back of the list or not\n\t\tthis.addAtBack = !!config.addAtBack;\n\t\t//reset the emitter position and rotation variables\n\t\tthis.rotation = 0;\n\t\tthis.ownerPos = new Point();\n\t\tthis.spawnPos = new Point(config.pos.x, config.pos.y);\n\t\tthis._prevEmitterPos = this.spawnPos.clone();\n\t\t//previous emitter position is invalid and should not be used for interpolation\n\t\tthis._prevPosIsValid = false;\n\t\t//start emitting\n\t\tthis._spawnTimer = 0;\n\t\tthis.emit = config.emit === undefined ? true : !!config.emit;\n\t\tthis.autoUpdate = config.autoUpdate === undefined ? false : !!config.autoUpdate;\n\t}\n\n\t/**\n\t * Recycles an individual particle.\n\t * @method PIXI.particles.Emitter#recycle\n\t * @param {Particle} particle The particle to recycle.\n\t * @private\n\t */\n\tpublic recycle(particle: Particle)\n\t{\n\t\tif(particle.next)\n\t\t\tparticle.next.prev = particle.prev;\n\t\tif(particle.prev)\n\t\t\tparticle.prev.next = particle.next;\n\t\tif(particle == this._activeParticlesLast)\n\t\t\tthis._activeParticlesLast = particle.prev;\n\t\tif(particle == this._activeParticlesFirst)\n\t\t\tthis._activeParticlesFirst = particle.next;\n\t\t//add to pool\n\t\tparticle.prev = null;\n\t\tparticle.next = this._poolFirst;\n\t\tthis._poolFirst = particle;\n\t\t//remove child from display, or make it invisible if it is in a ParticleContainer\n\t\tif(particle.parent)\n\t\t\tparticle.parent.removeChild(particle);\n\t\t//decrease count\n\t\t--this.particleCount;\n\t}\n\n\t/**\n\t * Sets the rotation of the emitter to a new value.\n\t * @method PIXI.particles.Emitter#rotate\n\t * @param {Number} newRot The new rotation, in degrees.\n\t */\n\tpublic rotate(newRot: number)\n\t{\n\t\tif (this.rotation == newRot) return;\n\t\t//caclulate the difference in rotation for rotating spawnPos\n\t\tlet diff = newRot - this.rotation;\n\t\tthis.rotation = newRot;\n\t\t//rotate spawnPos\n\t\tParticleUtils.rotatePoint(diff, this.spawnPos);\n\t\t//mark the position as having changed\n\t\tthis._posChanged = true;\n\t}\n\n\t/**\n\t * Changes the spawn position of the emitter.\n\t * @method PIXI.particles.Emitter#updateSpawnPos\n\t * @param {Number} x The new x value of the spawn position for the emitter.\n\t * @param {Number} y The new y value of the spawn position for the emitter.\n\t */\n\tpublic updateSpawnPos(x: number, y: number)\n\t{\n\t\tthis._posChanged = true;\n\t\tthis.spawnPos.x = x;\n\t\tthis.spawnPos.y = y;\n\t}\n\n\t/**\n\t * Changes the position of the emitter's owner. You should call this if you are adding\n\t * particles to the world container that your emitter's owner is moving around in.\n\t * @method PIXI.particles.Emitter#updateOwnerPos\n\t * @param {Number} x The new x value of the emitter's owner.\n\t * @param {Number} y The new y value of the emitter's owner.\n\t */\n\tpublic updateOwnerPos(x: number, y: number)\n\t{\n\t\tthis._posChanged = true;\n\t\tthis.ownerPos.x = x;\n\t\tthis.ownerPos.y = y;\n\t}\n\n\t/**\n\t * Prevents emitter position interpolation in the next update.\n\t * This should be used if you made a major position change of your emitter's owner\n\t * that was not normal movement.\n\t * @method PIXI.particles.Emitter#resetPositionTracking\n\t */\n\tpublic resetPositionTracking()\n\t{\n\t\tthis._prevPosIsValid = false;\n\t}\n\n\t/**\n\t * If particles should be emitted during update() calls. Setting this to false\n\t * stops new particles from being created, but allows existing ones to die out.\n\t * @member {Boolean} PIXI.particles.Emitter#emit\n\t */\n\tpublic get emit() { return this._emit; };\n\tpublic set emit(value)\n\t{\n\t\tthis._emit = !!value;\n\t\tthis._emitterLife = this.emitterLifetime;\n\t}\n\n\t/**\n\t * If the update function is called automatically from the shared ticker.\n\t * Setting this to false requires calling the update function manually.\n\t * @member {Boolean} PIXI.particles.Emitter#autoUpdate\n\t */\n\tpublic get autoUpdate() { return this._autoUpdate; }\n\tpublic set autoUpdate(value)\n\t{\n\t\tif (this._autoUpdate && !value)\n\t\t{\n\t\t\tticker.remove(this.update, this);\n\t\t}\n\t\telse if (!this._autoUpdate && value)\n\t\t{\n\t\t\tticker.add(this.update, this);\n\t\t}\n\t\tthis._autoUpdate = !!value;\n\t}\n\n\t/**\n\t * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself\n\t * when particle emission is complete.\n\t * @method PIXI.particles.Emitter#playOnceAndDestroy\n\t * @param {Function} [callback] Callback for when emission is complete (all particles have died off)\n\t */\n\tpublic playOnceAndDestroy(callback?: () => void)\n\t{\n\t\tthis.autoUpdate = true;\n\t\tthis.emit = true;\n\t\tthis._destroyWhenComplete = true;\n\t\tthis._completeCallback = callback;\n\t}\n\n\t/**\n\t * Starts emitting particles and optionally calls a callback when particle emission is complete.\n\t * @method PIXI.particles.Emitter#playOnce\n\t * @param {Function} [callback] Callback for when emission is complete (all particles have died off)\n\t */\n\tpublic playOnce(callback?: () => void)\n\t{\n\t\tthis.emit = true;\n\t\tthis._completeCallback = callback;\n\t}\n\n\t/**\n\t * Updates all particles spawned by this emitter and emits new ones.\n\t * @method PIXI.particles.Emitter#update\n\t * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n\t */\n\tpublic update(delta: number)\n\t{\n\t\tif (this._autoUpdate)\n\t\t{\n\t\t\tdelta = delta / settings.TARGET_FPMS / 1000;\n\t\t}\n\n\t\t//if we don't have a parent to add particles to, then don't do anything.\n\t\t//this also works as a isDestroyed check\n\t\tif (!this._parent) return;\n\t\t//update existing particles\n\t\tlet i, particle, next;\n\t\tfor (particle = this._activeParticlesFirst; particle; particle = next)\n\t\t{\n\t\t\tnext = particle.next;\n\t\t\tparticle.update(delta);\n\t\t}\n\t\tlet prevX, prevY;\n\t\t//if the previous position is valid, store these for later interpolation\n\t\tif(this._prevPosIsValid)\n\t\t{\n\t\t\tprevX = this._prevEmitterPos.x;\n\t\t\tprevY = this._prevEmitterPos.y;\n\t\t}\n\t\t//store current position of the emitter as local variables\n\t\tlet curX = this.ownerPos.x + this.spawnPos.x;\n\t\tlet curY = this.ownerPos.y + this.spawnPos.y;\n\t\t//spawn new particles\n\t\tif (this._emit)\n\t\t{\n\t\t\t//decrease spawn timer\n\t\t\tthis._spawnTimer -=  delta < 0 ? 0 : delta;\n\t\t\t//while _spawnTimer < 0, we have particles to spawn\n\t\t\twhile(this._spawnTimer <= 0)\n\t\t\t{\n\t\t\t\t//determine if the emitter should stop spawning\n\t\t\t\tif(this._emitterLife > 0)\n\t\t\t\t{\n\t\t\t\t\tthis._emitterLife -= this._frequency;\n\t\t\t\t\tif(this._emitterLife <= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis._spawnTimer = 0;\n\t\t\t\t\t\tthis._emitterLife = 0;\n\t\t\t\t\t\tthis.emit = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//determine if we have hit the particle limit\n\t\t\t\tif(this.particleCount >= this.maxParticles)\n\t\t\t\t{\n\t\t\t\t\tthis._spawnTimer += this._frequency;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//determine the particle lifetime\n\t\t\t\tlet lifetime;\n\t\t\t\tif (this.minLifetime == this.maxLifetime)\n\t\t\t\t\tlifetime = this.minLifetime;\n\t\t\t\telse\n\t\t\t\t\tlifetime = Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime;\n\t\t\t\t//only make the particle if it wouldn't immediately destroy itself\n\t\t\t\tif(-this._spawnTimer < lifetime)\n\t\t\t\t{\n\t\t\t\t\t//If the position has changed and this isn't the first spawn,\n\t\t\t\t\t//interpolate the spawn position\n\t\t\t\t\tlet emitPosX, emitPosY;\n\t\t\t\t\tif (this._prevPosIsValid && this._posChanged)\n\t\t\t\t\t{\n\t\t\t\t\t\t//1 - _spawnTimer / delta, but _spawnTimer is negative\n\t\t\t\t\t\tlet lerp = 1 + this._spawnTimer / delta;\n\t\t\t\t\t\temitPosX = (curX - prevX) * lerp + prevX;\n\t\t\t\t\t\temitPosY = (curY - prevY) * lerp + prevY;\n\t\t\t\t\t}\n\t\t\t\t\telse//otherwise just set to the spawn position\n\t\t\t\t\t{\n\t\t\t\t\t\temitPosX = curX;\n\t\t\t\t\t\temitPosY = curY;\n\t\t\t\t\t}\n\t\t\t\t\t//create enough particles to fill the wave (non-burst types have a wave of 1)\n\t\t\t\t\ti = 0;\n\t\t\t\t\tfor(let len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount); i < len; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\t//see if we actually spawn one\n\t\t\t\t\t\tif (this.spawnChance < 1 && Math.random() >= this.spawnChance)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t//create particle\n\t\t\t\t\t\tlet p;\n\t\t\t\t\t\tif(this._poolFirst)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp = this._poolFirst;\n\t\t\t\t\t\t\tthis._poolFirst = this._poolFirst.next;\n\t\t\t\t\t\t\tp.next = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp = new this.particleConstructor(this);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//set a random texture if we have more than one\n\t\t\t\t\t\tif(this.particleImages.length > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.applyArt(this.particleImages[Math.floor(Math.random() * this.particleImages.length)]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//if they are actually the same texture, a standard particle\n\t\t\t\t\t\t\t//will quit early from the texture setting in setTexture().\n\t\t\t\t\t\t\tp.applyArt(this.particleImages[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//set up the start and end values\n\t\t\t\t\t\tp.alphaList.reset(this.startAlpha);\n\t\t\t\t\t\tif(this.minimumSpeedMultiplier != 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.speedMultiplier = Math.random() * (1 - this.minimumSpeedMultiplier) + this.minimumSpeedMultiplier;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp.speedList.reset(this.startSpeed);\n\t\t\t\t\t\tp.acceleration.x = this.acceleration.x;\n\t\t\t\t\t\tp.acceleration.y = this.acceleration.y;\n\t\t\t\t\t\tp.maxSpeed = this.maxSpeed;\n\t\t\t\t\t\tif(this.minimumScaleMultiplier != 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.scaleMultiplier = Math.random() * (1 - this.minimumScaleMultiplier) + this.minimumScaleMultiplier;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp.scaleList.reset(this.startScale);\n\t\t\t\t\t\tp.colorList.reset(this.startColor);\n\t\t\t\t\t\t//randomize the rotation speed\n\t\t\t\t\t\tif(this.minRotationSpeed == this.maxRotationSpeed)\n\t\t\t\t\t\t\tp.rotationSpeed = this.minRotationSpeed;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tp.rotationSpeed = Math.random() * (this.maxRotationSpeed - this.minRotationSpeed) + this.minRotationSpeed;\n\t\t\t\t\t\tp.noRotation = this.noRotation;\n\t\t\t\t\t\t//set up the lifetime\n\t\t\t\t\t\tp.maxLife = lifetime;\n\t\t\t\t\t\t//set the blend mode\n\t\t\t\t\t\tp.blendMode = this.particleBlendMode;\n\t\t\t\t\t\t//set the custom ease, if any\n\t\t\t\t\t\tp.ease = this.customEase;\n\t\t\t\t\t\t//set the extra data, if any\n\t\t\t\t\t\tp.extraData = this.extraData;\n\t\t\t\t\t\t//call the proper function to handle rotation and position of particle\n\t\t\t\t\t\tthis._spawnFunc(p, emitPosX, emitPosY, i);\n\t\t\t\t\t\t//initialize particle\n\t\t\t\t\t\tp.init();\n\t\t\t\t\t\t//update the particle by the time passed, so the particles are spread out properly\n\t\t\t\t\t\tp.update(-this._spawnTimer);//we want a positive delta, because a negative delta messes things up\n\t\t\t\t\t\t//add the particle to the display list\n\t\t\t\t\t\tif(!p.parent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (this.addAtBack)\n\t\t\t\t\t\t\t\tthis._parent.addChildAt(p, 0);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tthis._parent.addChild(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//kind of hacky, but performance friendly\n\t\t\t\t\t\t\t//shuffle children to correct place\n\t\t\t\t\t\t\tlet children = this._parent.children;\n\t\t\t\t\t\t\t//avoid using splice if possible\n\t\t\t\t\t\t\tif(children[0] == p)\n\t\t\t\t\t\t\t\tchildren.shift();\n\t\t\t\t\t\t\telse if(children[children.length-1] == p)\n\t\t\t\t\t\t\t\tchildren.pop();\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlet index = children.indexOf(p);\n\t\t\t\t\t\t\t\tchildren.splice(index, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(this.addAtBack)\n\t\t\t\t\t\t\t\tchildren.unshift(p);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tchildren.push(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//add particle to list of active particles\n\t\t\t\t\t\tif(this._activeParticlesLast)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis._activeParticlesLast.next = p;\n\t\t\t\t\t\t\tp.prev = this._activeParticlesLast;\n\t\t\t\t\t\t\tthis._activeParticlesLast = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis._activeParticlesLast = this._activeParticlesFirst = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++this.particleCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//increase timer and continue on to any other particles that need to be created\n\t\t\t\tthis._spawnTimer += this._frequency;\n\t\t\t}\n\t\t}\n\t\t//if the position changed before this update, then keep track of that\n\t\tif(this._posChanged)\n\t\t{\n\t\t\tthis._prevEmitterPos.x = curX;\n\t\t\tthis._prevEmitterPos.y = curY;\n\t\t\tthis._prevPosIsValid = true;\n\t\t\tthis._posChanged = false;\n\t\t}\n\n\t\t//if we are all done and should destroy ourselves, take care of that\n\t\tif (!this._emit && !this._activeParticlesFirst)\n\t\t{\n\t\t\tif (this._completeCallback)\n\t\t\t{\n\t\t\t\tthis._completeCallback();\n\t\t\t}\n\t\t\tif (this._destroyWhenComplete)\n\t\t\t{\n\t\t\t\tthis.destroy();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Positions a particle for a point type emitter.\n\t * @method PIXI.particles.Emitter#_spawnPoint\n\t * @private\n\t * @param {Particle} p The particle to position and rotate.\n\t * @param {Number} emitPosX The emitter's x position\n\t * @param {Number} emitPosY The emitter's y position\n\t * @param {int} i The particle number in the current wave. Not used for this function.\n\t */\n\tprotected _spawnPoint(p: Particle, emitPosX: number, emitPosY: number)\n\t{\n\t\t//set the initial rotation/direction of the particle based on\n\t\t//starting particle angle and rotation of emitter\n\t\tif (this.minStartRotation == this.maxStartRotation)\n\t\t\tp.rotation = this.minStartRotation + this.rotation;\n\t\telse\n\t\t\tp.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation;\n\t\t//drop the particle at the emitter's position\n\t\tp.position.x = emitPosX;\n\t\tp.position.y = emitPosY;\n\t}\n\n\t/**\n\t * Positions a particle for a rectangle type emitter.\n\t * @method PIXI.particles.Emitter#_spawnRect\n\t * @private\n\t * @param {Particle} p The particle to position and rotate.\n\t * @param {Number} emitPosX The emitter's x position\n\t * @param {Number} emitPosY The emitter's y position\n\t * @param {int} i The particle number in the current wave. Not used for this function.\n\t */\n\tprotected _spawnRect(p: Particle, emitPosX: number, emitPosY: number)\n\t{\n\t\t//set the initial rotation/direction of the particle based on starting\n\t\t//particle angle and rotation of emitter\n\t\tif (this.minStartRotation == this.maxStartRotation)\n\t\t\tp.rotation = this.minStartRotation + this.rotation;\n\t\telse\n\t\t\tp.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation;\n\t\t//place the particle at a random point in the rectangle\n\t\thelperPoint.x = Math.random() * this.spawnRect.width + this.spawnRect.x;\n\t\thelperPoint.y = Math.random() * this.spawnRect.height + this.spawnRect.y;\n\t\tif(this.rotation !== 0)\n\t\t\tParticleUtils.rotatePoint(this.rotation, helperPoint);\n\t\tp.position.x = emitPosX + helperPoint.x;\n\t\tp.position.y = emitPosY + helperPoint.y;\n\t}\n\n\t/**\n\t * Positions a particle for a circle type emitter.\n\t * @method PIXI.particles.Emitter#_spawnCircle\n\t * @private\n\t * @param {Particle} p The particle to position and rotate.\n\t * @param {Number} emitPosX The emitter's x position\n\t * @param {Number} emitPosY The emitter's y position\n\t * @param {int} i The particle number in the current wave. Not used for this function.\n\t */\n\tprotected _spawnCircle(p: Particle, emitPosX: number, emitPosY: number)\n\t{\n\t\t//set the initial rotation/direction of the particle based on starting\n\t\t//particle angle and rotation of emitter\n\t\tif (this.minStartRotation == this.maxStartRotation)\n\t\t\tp.rotation = this.minStartRotation + this.rotation;\n\t\telse\n\t\t\tp.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\n\t\t\t\t\t\tthis.minStartRotation + this.rotation;\n\t\t//place the particle at a random radius in the circle\n\t\thelperPoint.x = Math.random() * this.spawnCircle.radius;\n\t\thelperPoint.y = 0;\n\t\t//rotate the point to a random angle in the circle\n\t\tParticleUtils.rotatePoint(Math.random() * 360, helperPoint);\n\t\t//offset by the circle's center\n\t\thelperPoint.x += this.spawnCircle.x;\n\t\thelperPoint.y += this.spawnCircle.y;\n\t\t//rotate the point by the emitter's rotation\n\t\tif(this.rotation !== 0)\n\t\t\tParticleUtils.rotatePoint(this.rotation, helperPoint);\n\t\t//set the position, offset by the emitter's position\n\t\tp.position.x = emitPosX + helperPoint.x;\n\t\tp.position.y = emitPosY + helperPoint.y;\n\t}\n\n\t/**\n\t * Positions a particle for a ring type emitter.\n\t * @method PIXI.particles.Emitter#_spawnRing\n\t * @private\n\t * @param {Particle} p The particle to position and rotate.\n\t * @param {Number} emitPosX The emitter's x position\n\t * @param {Number} emitPosY The emitter's y position\n\t * @param {int} i The particle number in the current wave. Not used for this function.\n\t */\n\tprotected _spawnRing(p: Particle, emitPosX: number, emitPosY: number)\n\t{\n\t\tlet spawnCircle = this.spawnCircle;\n\t\t//set the initial rotation/direction of the particle based on starting\n\t\t//particle angle and rotation of emitter\n\t\tif (this.minStartRotation == this.maxStartRotation)\n\t\t\tp.rotation = this.minStartRotation + this.rotation;\n\t\telse\n\t\t\tp.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\n\t\t\t\t\t\tthis.minStartRotation + this.rotation;\n\t\t//place the particle at a random radius in the ring\n\t\tif(spawnCircle.minRadius !== spawnCircle.radius)\n\t\t{\n\t\t\thelperPoint.x = Math.random() * (spawnCircle.radius - spawnCircle.minRadius) +\n\t\t\t\t\t\t\tspawnCircle.minRadius;\n\t\t}\n\t\telse\n\t\t\thelperPoint.x = spawnCircle.radius;\n\t\thelperPoint.y = 0;\n\t\t//rotate the point to a random angle in the circle\n\t\tlet angle = Math.random() * 360;\n\t\tp.rotation += angle;\n\t\tParticleUtils.rotatePoint(angle, helperPoint);\n\t\t//offset by the circle's center\n\t\thelperPoint.x += this.spawnCircle.x;\n\t\thelperPoint.y += this.spawnCircle.y;\n\t\t//rotate the point by the emitter's rotation\n\t\tif(this.rotation !== 0)\n\t\t\tParticleUtils.rotatePoint(this.rotation, helperPoint);\n\t\t//set the position, offset by the emitter's position\n\t\tp.position.x = emitPosX + helperPoint.x;\n\t\tp.position.y = emitPosY + helperPoint.y;\n\t}\n\n\t/**\n\t * Positions a particle for polygonal chain.\n\t * @method PIXI.particles.Emitter#_spawnPolygonalChain\n\t * @private\n\t * @param {Particle} p The particle to position and rotate.\n\t * @param {Number} emitPosX The emitter's x position\n\t * @param {Number} emitPosY The emitter's y position\n\t * @param {int} i The particle number in the current wave. Not used for this function.\n\t */\n\tprotected _spawnPolygonalChain(p: Particle, emitPosX: number, emitPosY: number)\n\t{\n\t\t//set the initial rotation/direction of the particle based on starting\n\t\t//particle angle and rotation of emitter\n\t\tif (this.minStartRotation == this.maxStartRotation)\n\t\t\tp.rotation = this.minStartRotation + this.rotation;\n\t\telse\n\t\t\tp.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\n\t\t\t\tthis.minStartRotation + this.rotation;\n\t\t// get random point on the polygon chain\n\t\tthis.spawnPolygonalChain.getRandomPoint(helperPoint);\n\t\t//rotate the point by the emitter's rotation\n\t\tif(this.rotation !== 0)\n\t\t\tParticleUtils.rotatePoint(this.rotation, helperPoint);\n\t\t//set the position, offset by the emitter's position\n\t\tp.position.x = emitPosX + helperPoint.x;\n\t\tp.position.y = emitPosY + helperPoint.y;\n\t}\n\n\t/**\n\t * Positions a particle for a burst type emitter.\n\t * @method PIXI.particles.Emitter#_spawnBurst\n\t * @private\n\t * @param {Particle} p The particle to position and rotate.\n\t * @param {Number} emitPosX The emitter's x position\n\t * @param {Number} emitPosY The emitter's y position\n\t * @param {int} i The particle number in the current wave.\n\t */\n\tpublic _spawnBurst(p: Particle, emitPosX: number, emitPosY: number, i: number)\n\t{\n\t\t//set the initial rotation/direction of the particle based on spawn\n\t\t//angle and rotation of emitter\n\t\tif(this.particleSpacing === 0)\n\t\t\tp.rotation = Math.random() * 360;\n\t\telse\n\t\t\tp.rotation = this.angleStart + (this.particleSpacing * i) + this.rotation;\n\t\t//drop the particle at the emitter's position\n\t\tp.position.x = emitPosX;\n\t\tp.position.y = emitPosY;\n\t}\n\n\t/**\n\t * Kills all active particles immediately.\n\t * @method PIXI.particles.Emitter#cleanup\n\t */\n\tpublic cleanup()\n\t{\n\t\tlet particle, next;\n\t\tfor (particle = this._activeParticlesFirst; particle; particle = next)\n\t\t{\n\t\t\tnext = particle.next;\n\t\t\tthis.recycle(particle);\n\t\t\tif(particle.parent)\n\t\t\t\tparticle.parent.removeChild(particle);\n\t\t}\n\t\tthis._activeParticlesFirst = this._activeParticlesLast = null;\n\t\tthis.particleCount = 0;\n\t}\n\n\t/**\n\t * Destroys the emitter and all of its particles.\n\t * @method PIXI.particles.Emitter#destroy\n\t */\n\tpublic destroy()\n\t{\n\t\t//make sure we aren't still listening to any tickers\n\t\tthis.autoUpdate = false;\n\t\t//puts all active particles in the pool, and removes them from the particle parent\n\t\tthis.cleanup();\n\t\t//wipe the pool clean\n\t\tlet next;\n\t\tfor (let particle = this._poolFirst; particle; particle = next)\n\t\t{\n\t\t\t//store next value so we don't lose it in our destroy call\n\t\t\tnext = particle.next;\n\t\t\tparticle.destroy();\n\t\t}\n\t\tthis._poolFirst = this._parent = this.particleImages = this.spawnPos = this.ownerPos =\n\t\t\tthis.startColor = this.startScale = this.startAlpha = this.startSpeed =\n\t\t\tthis.customEase = this._completeCallback = null;\n\t}\n}\n","import ParticleUtils from \"./ParticleUtils\";\nimport Particle from \"./Particle\";\nimport Emitter from \"./Emitter\";\nimport {Point} from 'pixi.js';\n\n/**\n * A helper point for math things.\n * @private\n */\nconst helperPoint = new Point();\n\n//a hand picked list of Math functions (and a couple properties) that are allowable.\n//they should be used without the preceding \"Math.\"\nconst MATH_FUNCS =\n[\n\t\"pow\",\n\t\"sqrt\",\n\t\"abs\",\n\t\"floor\",\n\t\"round\",\n\t\"ceil\",\n\t\"E\",\n\t\"PI\",\n\t\"sin\",\n\t\"cos\",\n\t\"tan\",\n\t\"asin\",\n\t\"acos\",\n\t\"atan\",\n\t\"atan2\",\n\t\"log\"\n];\n//create an actual regular expression object from the string\nconst WHITELISTER = new RegExp(\n\t[\n\t\t//Allow the 4 basic operations, parentheses and all numbers/decimals, as well\n\t\t//as 'x', for the variable usage.\n\t\t\"[01234567890\\\\.\\\\*\\\\-\\\\+\\\\/\\\\(\\\\)x ,]\",\n\t].concat(MATH_FUNCS).join(\"|\"),\n\t\"g\"\n);\n\n/**\n * Parses a string into a function for path following.\n * This involves whitelisting the string for safety, inserting \"Math.\" to math function\n * names, and using `new Function()` to generate a function.\n * @method PIXI.particles.PathParticle~parsePath\n * @private\n * @static\n * @param {String} pathString The string to parse.\n * @return {Function} The path function - takes x, outputs y.\n */\nconst parsePath = function(pathString: string)\n{\n\tlet matches = pathString.match(WHITELISTER);\n\tfor(let i = matches.length - 1; i >= 0; --i)\n\t{\n\t\tif(MATH_FUNCS.indexOf(matches[i]) >= 0)\n\t\t\tmatches[i] = \"Math.\" + matches[i];\n\t}\n\tpathString = matches.join(\"\");\n\treturn new Function(\"x\", \"return \"+ pathString + \";\");\n};\n\n/**\n * An particle that follows a path defined by an algebraic expression, e.g. \"sin(x)\" or\n * \"5x + 3\".\n * To use this class, the particle config must have a \"path\" string in the\n * \"extraData\" parameter. This string should have \"x\" in it to represent movement (from the\n * speed settings of the particle). It may have numbers, parentheses, the four basic\n * operations, and the following Math functions or properties (without the preceding \"Math.\"):\n * \"pow\", \"sqrt\", \"abs\", \"floor\", \"round\", \"ceil\", \"E\", \"PI\", \"sin\", \"cos\", \"tan\", \"asin\",\n * \"acos\", \"atan\", \"atan2\", \"log\".\n * The overall movement of the particle and the expression value become x and y positions for\n * the particle, respectively. The final position is rotated by the spawn rotation/angle of\n * the particle.\n *\n * Some example paths:\n *\n * \t\"sin(x/10) * 20\" // A sine wave path.\n * \t\"cos(x/100) * 30\" // Particles curve counterclockwise (for medium speed/low lifetime particles)\n * \t\"pow(x/10, 2) / 2\" // Particles curve clockwise (remember, +y is down).\n *\n * @memberof PIXI.particles\n * @class PathParticle\n * @extends PIXI.particles.Particle\n * @constructor\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this PathParticle.\n */\nexport default class PathParticle extends Particle\n{\n\t/**\n\t * The function representing the path the particle should take.\n\t * @property {Function} path\n\t */\n\tpublic path: Function;\n\t/**\n\t * The initial rotation in degrees of the particle, because the direction of the path\n\t * is based on that.\n\t * @property {Number} initialRotation\n\t */\n\tpublic initialRotation: number;\n\t/**\n\t * The initial position of the particle, as all path movement is added to that.\n\t * @property {PIXI.Point} initialPosition\n\t */\n\tpublic initialPosition: Point;\n\t/**\n\t * Total single directional movement, due to speed.\n\t * @property {Number} movement\n\t */\n\tpublic movement: number;\n\t\n\tconstructor(emitter: Emitter)\n\t{\n\t\tsuper(emitter);\n\t\tthis.path = null;\n\t\tthis.initialRotation = 0;\n\t\tthis.initialPosition = new Point();\n\t\tthis.movement = 0;\n\t}\n\n\t/**\n\t * Initializes the particle for use, based on the properties that have to\n\t * have been set already on the particle.\n\t * @method PIXI.particles.PathParticle#init\n\t */\n\tpublic init()\n\t{\n\t\t//get initial rotation before it is converted to radians\n\t\tthis.initialRotation = this.rotation;\n\t\t//standard init\n\t\tthis.Particle_init();\n\n\t\t//set the path for the particle\n\t\tthis.path = this.extraData.path;\n\t\t//cancel the normal movement behavior\n\t\tthis._doNormalMovement = !this.path;\n\t\t//reset movement\n\t\tthis.movement = 0;\n\t\t//grab position\n\t\tthis.initialPosition.x = this.position.x;\n\t\tthis.initialPosition.y = this.position.y;\n\t}\n\n\t/**\n\t * Updates the particle.\n\t * @method PIXI.particles.PathParticle#update\n\t * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n\t */\n\tpublic update(delta: number): number\n\t{\n\t\tconst lerp = this.Particle_update(delta);\n\t\t//if the particle died during the update, then don't bother\n\t\tif(lerp >= 0 && this.path)\n\t\t{\n\t\t\t//increase linear movement based on speed\n\t\t\tconst speed = this.speedList.interpolate(lerp) * this.speedMultiplier;\n\t\t\tthis.movement += speed * delta;\n\t\t\t//set up the helper point for rotation\n\t\t\thelperPoint.x = this.movement;\n\t\t\thelperPoint.y = this.path(this.movement);\n\t\t\tParticleUtils.rotatePoint(this.initialRotation, helperPoint);\n\t\t\tthis.position.x = this.initialPosition.x + helperPoint.x;\n\t\t\tthis.position.y = this.initialPosition.y + helperPoint.y;\n\t\t}\n\t\treturn lerp;\n\t}\n\t\n\t/**\n\t * Destroys the particle, removing references and preventing future use.\n\t * @method PIXI.particles.PathParticle#destroy\n\t */\n\tpublic destroy()\n\t{\n\t\tthis.Particle_destroy();\n\t\tthis.path = this.initialPosition = null;\n\t}\n\n\t/**\n\t * Checks over the art that was passed to the Emitter's init() function, to do any special\n\t * modifications to prepare it ahead of time. This just runs Particle.parseArt().\n\t * @method PIXI.particles.PathParticle.parseArt\n\t * @static\n\t * @param  {Array} art The array of art data. For Particle, it should be an array of Textures.\n\t *                     Any strings in the array will be converted to Textures via\n\t *                     Texture.fromImage().\n\t * @return {Array} The art, after any needed modifications.\n\t */\n\tpublic static parseArt(art: any[])\n\t{\n\t\treturn Particle.parseArt(art);\n\t}\n\n\t/**\n\t * Parses extra emitter data to ensure it is set up for this particle class.\n\t * PathParticle checks for the existence of path data, and parses the path data for use\n\t * by particle instances.\n\t * @method PIXI.particles.PathParticle.parseData\n\t * @static\n\t * @param  {Object} extraData The extra data from the particle config.\n\t * @return {Object} The parsed extra data.\n\t */\n\tpublic static parseData(extraData: {path:string})\n\t{\n\t\tlet output: any = {};\n\t\tif(extraData && extraData.path)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\toutput.path = parsePath(extraData.path);\n\t\t\t}\n\t\t\tcatch(e)\n\t\t\t{\n\t\t\t\tif(ParticleUtils.verbose)\n\t\t\t\t\tconsole.error(\"PathParticle: error in parsing path expression\");\n\t\t\t\toutput.path = null;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(ParticleUtils.verbose)\n\t\t\t\tconsole.error(\"PathParticle requires a path string in extraData!\");\n\t\t\toutput.path = null;\n\t\t}\n\t\treturn output;\n\t}\n}","import Particle from \"./Particle\";\nimport Emitter from \"./Emitter\";\nimport {Texture} from 'pixi.js';\n\nexport interface ParsedAnimatedParticleArt\n{\n\ttextures: Texture[];\n\tduration: number;\n\tframerate: number;\n\tloop: boolean;\n}\n\nexport interface AnimatedParticleArt\n{\n\tframerate: \"matchLife\"|number;\n\tloop?: boolean;\n\ttextures: (string|Texture|{texture:string|Texture,count:number})[];\n}\n\n/**\n * An individual particle image with an animation. Art data passed to the emitter must be\n * formatted in a particular way for AnimatedParticle to be able to handle it:\n *\n *     {\n *         //framerate is required. It is the animation speed of the particle in frames per\n *         //second.\n *         //A value of \"matchLife\" causes the animation to match the lifetime of an individual\n *         //particle, instead of at a constant framerate. This causes the animation to play\n *         //through one time, completing when the particle expires.\n *         framerate: 6,\n *         //loop is optional, and defaults to false.\n *         loop: true,\n *         //textures is required, and can be an array of any (non-zero) length.\n *         textures: [\n *             //each entry represents a single texture that should be used for one or more\n *             //frames. Any strings will be converted to Textures with Texture.fromImage().\n *             //Instances of PIXI.Texture will be used directly.\n *             \"animFrame1.png\",\n *             //entries can be an object with a 'count' property, telling AnimatedParticle to\n *             //use that texture for 'count' frames sequentially.\n *             {\n *                 texture: \"animFrame2.png\",\n *                 count: 3\n *             },\n *             \"animFrame3.png\"\n *         ]\n *     }\n *\n * @memberof PIXI.particles\n * @class AnimatedParticle\n * @extends PIXI.particles.Particle\n * @constructor\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this AnimatedParticle.\n */\nexport default class AnimatedParticle extends Particle\n{\n\t/**\n\t * Texture array used as each frame of animation, similarly to how MovieClip works.\n\t * @property {Array} textures\n\t * @private\n\t */\n\tprivate textures: Texture[];\n\n\t/**\n\t * Duration of the animation, in seconds.\n\t * @property {Number} duration\n\t * @private\n\t */\n\tprivate duration: number;\n\n\t/**\n\t * Animation framerate, in frames per second.\n\t * @property {Number} framerate\n\t * @private\n\t */\n\tprivate framerate: number;\n\n\t/**\n\t * Animation time elapsed, in seconds.\n\t * @property {Number} elapsed\n\t * @private\n\t */\n\tprivate elapsed: number;\n\n\t/**\n\t * If this particle animation should loop.\n\t * @property {Boolean} loop\n\t * @private\n\t */\n\tprivate loop: boolean;\n\t\n\tconstructor(emitter: Emitter)\n\t{\n\t\tsuper(emitter);\n\n\t\tthis.textures = null;\n\t\tthis.duration = 0;\n\t\tthis.framerate = 0;\n\t\tthis.elapsed = 0;\n\t\tthis.loop = false;\n\t}\n\n\t/**\n\t * Initializes the particle for use, based on the properties that have to\n\t * have been set already on the particle.\n\t * @method PIXI.particles.AnimatedParticle#init\n\t */\n\tpublic init()\n\t{\n\t\tthis.Particle_init();\n\n\t\tthis.elapsed = 0;\n\n\t\t//if the animation needs to match the particle's life, then cacluate variables\n\t\tif(this.framerate < 0)\n\t\t{\n\t\t\tthis.duration = this.maxLife;\n\t\t\tthis.framerate = this.textures.length / this.duration;\n\t\t}\n\t}\n\n\t/**\n\t * Sets the textures for the particle.\n\t * @method PIXI.particles.AnimatedParticle#applyArt\n\t * @param {Array} art An array of PIXI.Texture objects for this animated particle.\n\t */\n\tpublic applyArt(art: ParsedAnimatedParticleArt)\n\t{\n\t\tthis.textures = art.textures;\n\t\tthis.framerate = art.framerate;\n\t\tthis.duration = art.duration;\n\t\tthis.loop = art.loop;\n\t}\n\n\t/**\n\t * Updates the particle.\n\t * @method PIXI.particles.AnimatedParticle#update\n\t * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n\t */\n\tpublic update(delta: number): number\n\t{\n\t\tconst lerp = this.Particle_update(delta);\n\t\t//only animate the particle if it is still alive\n\t\tif(lerp >= 0)\n\t\t{\n\t\t\tthis.elapsed += delta;\n\t\t\tif(this.elapsed > this.duration)\n\t\t\t{\n\t\t\t\t//loop elapsed back around\n\t\t\t\tif(this.loop)\n\t\t\t\t\tthis.elapsed = this.elapsed % this.duration;\n\t\t\t\t//subtract a small amount to prevent attempting to go past the end of the animation\n\t\t\t\telse\n\t\t\t\t\tthis.elapsed = this.duration - 0.000001;\n\t\t\t}\n\t\t\tlet frame = (this.elapsed * this.framerate + 0.0000001) | 0;\n\t\t\tthis.texture = this.textures[frame] || Texture.EMPTY;\n\t\t}\n\t\treturn lerp;\n\t}\n\n\t/**\n\t * Destroys the particle, removing references and preventing future use.\n\t * @method PIXI.particles.AnimatedParticle#destroy\n\t */\n\tpublic destroy()\n\t{\n\t\tthis.Particle_destroy();\n\t\tthis.textures = null;\n\t}\n\n\t/**\n\t * Checks over the art that was passed to the Emitter's init() function, to do any special\n\t * modifications to prepare it ahead of time.\n\t * @method PIXI.particles.AnimatedParticle.parseArt\n\t * @static\n\t * @param  {Array} art The array of art data, properly formatted for AnimatedParticle.\n\t * @return {Array} The art, after any needed modifications.\n\t */\n\tpublic static parseArt(art: AnimatedParticleArt[])\n\t{\n\t\tlet data, output: any, textures, tex, outTextures;\n\t\tlet outArr:ParsedAnimatedParticleArt[] = [];\n\t\tfor(let i = 0; i < art.length; ++i)\n\t\t{\n\t\t\tdata = art[i];\n\t\t\toutArr[i] = output = {} as ParsedAnimatedParticleArt;\n\t\t\toutput.textures = outTextures = [];\n\t\t\ttextures = data.textures;\n\t\t\tfor(let j = 0; j < textures.length; ++j)\n\t\t\t{\n\t\t\t\ttex = textures[j];\n\t\t\t\tif(typeof tex == \"string\")\n\t\t\t\t\toutTextures.push(Texture.fromImage(tex));\n\t\t\t\telse if(tex instanceof Texture)\n\t\t\t\t\toutTextures.push(tex);\n\t\t\t\t//assume an object with extra data determining duplicate frame data\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet dupe = tex.count || 1;\n\t\t\t\t\tif(typeof tex.texture == \"string\")\n\t\t\t\t\t\ttex = Texture.fromImage(tex.texture);\n\t\t\t\t\telse// if(tex.texture instanceof Texture)\n\t\t\t\t\t\ttex = tex.texture;\n\t\t\t\t\tfor(; dupe > 0; --dupe)\n\t\t\t\t\t{\n\t\t\t\t\t\toutTextures.push(tex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//use these values to signify that the animation should match the particle life time.\n\t\t\tif(data.framerate == \"matchLife\")\n\t\t\t{\n\t\t\t\t//-1 means that it should be calculated\n\t\t\t\toutput.framerate = -1;\n\t\t\t\toutput.duration = 0;\n\t\t\t\toutput.loop = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//determine if the animation should loop\n\t\t\t\toutput.loop = !!data.loop;\n\t\t\t\t//get the framerate, default to 60\n\t\t\t\toutput.framerate = data.framerate > 0 ? data.framerate : 60;\n\t\t\t\t//determine the duration\n\t\t\t\toutput.duration = outTextures.length / output.framerate;\n\t\t\t}\n\t\t}\n\n\t\treturn outArr;\n\t}\n}",null]}